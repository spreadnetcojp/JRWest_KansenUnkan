--------
2015
--------

ウィンドウの左上に監視盤の一覧を、その右に改札機の一覧を DataGridView で表示する。
監視盤を選択すると、改札機の一覧が更新される。
２つの DataTable を DataSet に入れて、監視盤の ADDRESS 列と改札機の MONITOR_ADDRESS 列を DataRelation で紐づける。

改札機の一覧には、接続状態列がある。
値は「接続」「切断」「登録なし」から選択可能。

	「登録なし」は、監視盤の機器構成に登録されていない状態とする。
	つまり、機器接続状態に当該改札機のレコードを入れない。
	また、監視盤は、運管からマスタやプログラムを受け入れる上で、前回受け入れたものを全号機に配信しているかチェックするが、そのチェックからも除外する。
	運管的には「休止号機」扱いするべき改札機？

	「切断」の改札機は、機器接続状態でも「切断」になる。
	また、DeliverAllMasToTerm処理が要求された際、当該改札機には配信を行わない。
	#だからといって、接続状態を「接続」に変更した際に、過去のDeliverAllMasToTerm処理に対応する配信を行うわけではない。
	#DeliverAllMasToTermのように入力無しで実行できる処理（「CallExtAppFunc」で要求される処理の一部）については、
	#GUIから実行できるように専用のボタンを用意してもよいが、作成される DlReflect_*.dat をシミュレータ本体に
	#送信させないことには意味がないので、微妙な感じ。そもそも、どのディレクトリに作成するのかという問題もある。

■アプリの初回起動時から、一覧が表示されるべきである気がする。
GateManagerディレクトリの直下に Machines.csv（監視盤および改札機の一覧）があり、
要求受信時には、現状のようにタイムスタンプ不一致なら読み直すとして...
	・アプリ起動時にも読み込むようにしたい。
	・また、アプリ起動時になかった場合のために、「機器構成をSim本体に一致させる」ボタンも用意したい。

問題は、要求を受けないとシミュレータの作業ディレクトリがわからないこと。
シミュレータ側に外部からの要求受信用のMSMQを用意するとしても、このシミュレータは
複数起動できるべきであるから、MSMQ名は固定にすることができない。

→シミュレータ側のシナリオタブあたりに機器構成通知ボタンを用意する？
ただし、通知先MSMQ名のTextBoxなども必要になるだろうから、
シナリオにおける要求が必ずそこに送信されると誤解されそう...

→というか、監視盤モードなシミュレータのインスタンスを複数起動した場合などを考えると、
GateManagerディレクトリは複数あり得るわけだから、そこにある１つの機器構成を読むという仕様は間違いである。
やっぱり、機器構成ファイルは、模擬対象機器ごとに用意されるべきである。
DataGridViewに表示できるよう、それを１つの DataTable にマージする。
過去にあった（実際には、既にどのシミュレータにもない）行の管理が面倒だが、
最終読み取り日時のような列を用意し、それでソートして手動で削除してもらえばよいか...

→鬱陶しすぎるので、監視盤モードなシミュレータ本体のインスタンスは１つだけであることを前提に、
ユーザインタフェースを単純化した。

■DataTable は CSV ファイルに保存する？
	・CSV ファイルのフォーマットは、機器ディレクトリにあるものとほぼ同じ。
	・改札機の方（改札機の行？）だけ、接続状態列を追加する？
	・これらの CSV ファイルの読み込み（DataTable の作成）自体は、同一のメソッドで行う。
	・機器ディレクトリにあるものを読んだ際は、もともとある DataTable の
	　接続状態列の値を残したまま、余分な行の削除、新規行の追加を行うが、
	　あくまでも新旧の DataTable を用意してからの処理とする。

→いろんなファイルができると、ユーザにとって管理が面倒になると思われるため、
XmlSerializerで１ファイルに。

■監視盤のマスタ保持状態と改札機のマスタ保持状態についても、機器構成とは別のテーブルを用意する？
たとえば、改札機のためのマスタ保持状態テーブルの中から特定改札機の行を抽出する際は、
それらのテーブルからMACHINE_IDがTermMachine名（G070001006001など）と一致する行を抽出する感じ？

→監視盤一覧と改札機一覧のための DataTable にも不可視の「MACHINE_ID」列を追加し、マスタ表示状態等も
DataRelation でライブ切替可能にすると使いやすい？
監視盤と改札機の一覧は上下にならべ、それぞれの右側に状態（保持部材等）の一覧を表示する。
ただし、プログラムバージョンを表示したい場合やマスタバージョンを表示したい場合など
色々なケースがあると思われるため、右側全体を TabControl の中に入れる。

→監視盤の状態のための表に複数行が割り当てられるのは勿体ない。
	・１つの監視盤の状態を表示するなら、１行で済む。
	　たとえば、全種類のマスタのバージョン等をまとめて表示するにしても、それは、横並びに表示させるべきであるから、複数行は使用しない。
	・複数の監視盤の状態を表示する（各監視盤について、配信の保留件数などのサマリを表示する）なら、有意義であるように思えるが、
	　そもそも、それならば、１つの表に入っている方が見やすいはず。
	　つまり、右側の表などというものは不要である。
	　ウィンドウ上部にモード変更用ボタンをならべて、１クリックでモード変更できるようにし、モードによって、
	　１つの表の右側の列（項目）を差し替えればよい。
	・マスタのバージョンなどは、監視盤の保持しているものと各改札機の保持しているものは、隣接して表示させたい。
	　１つの表にいれて、１〜２行目を監視盤の１世代目、２世代目とし、３行目以降を各改札機の行にしたい。
	　よって、下の表は、改札機の表というよりも、１つの監視盤（と配下の改札機）に関する表とし、
	　この表も、モードによって、列（項目）を差し替えるのがよい。
	・「接続状態」表示モードでは、右側の列は接続状態になるが、これのように、間違いなくGUIで変更可能にする項目は、
	　別のテーブルに格納するわけにはいかなくなるかもしれない。機器構成とそれを Join して作った一時的な DataTable を
	　DataSource とした場合に、もとのテーブルにコミットする簡単な方法があればよいのだが...
	　一時的な DataTable を破棄する際に、ダーティな行全てについて、同じ MACHINE_ID 等を持つもとのテーブルの行に
	　項目値を書き戻すだけ...では済まない。設定変更を動作にライブ反映させるには、DataGridView のセルの変更イベント
	　のようなものを毎回ハンドリングする感じか。
	　「マスタバージョン」表示モードなどでも、状態が変化した際は、無操作で表示が更新されて欲しいし、
	　やっぱり、改札機のテーブルに大量の列（項目）を用意し、モードごとに DataGridView で表示項目を絞る
	　という方が現実的か？
	　しかし、DSH_VER, DSH_SUB_KIND, KEN_VER, KEN_SUB_KIND などのフィールドがあるわけで、かなり嫌な感じの
	　テーブルになりそう。そもそも、プログラムのバージョンなどは、CAB の中に入っているファイルリストの
	　各行がフィールドになるわけで、それって固定でないはずだし...
	　別のテーブルにわけても、本質的には、無操作更新は可能なはず。もとのテーブルを変更した際、変更箇所に紐づく
	　表示用 DataTable の項目もピンポイントで変更すればよいだけ。その程度のことなら、DataGridView の
	　選択状態などが変わってしまうこともないだろうし。
	　DataView で（ある程度の性能は犠牲にしても）対応できればよいのだが...
	　→、表示用の一時的 DataTable を作成するという時点で、もともとのデータを DataTable などという汚くて遅いものに
	　入れておく意味はない。適切な Generic コレクションに入れておけばよい。それならば、はじめからメモリ上に
	　最適なデータ構造のインデックスがあるようなものだし、LINQを使うよりもさらに速いはず。

■リファクタリング

このアプリの内部では、マスタやプログラムが無い場合は、Master への参照や Program への参照を
Nothing にすることに統一した方がすっきりするかもしれない。
現状は、無い場合には必ず Nothing になるはずであるが、参照する際は、DataVersion が 0 の場合も、
わざわざ「無い」体で動作するように実装している（これが鬱陶しい）。基本的にバージョン 0 の
ものがある体で動作して問題ないはず。たとえば、その場合にグリッドに 0 と表示されるなら、
不正な部材が入っていることがわかるし、自動追加した機器の初期プログラムに「バージョン 0」を
名乗らせることもできる。
ただし、外部から渡されるバージョンがあるなら、そこだけは、これまでどおり 0 を特別扱いする
ように実装しなければならない。実装を機械的に統一できなくなるわけであるが、このアプリは
改札機も内蔵しており、改札機から数値でバージョンを伝えられるということが無いため、
特別扱いする箇所はなさそう？

■プログラム配信状態のグリッドをダブルクリックしたときのモードレスダイアログ（GateProContentForm）を実装。

表示しているダイアログは、String（監視盤の機器ID+エリア番号+代表バージョン）とGateProContentFormの
Dictionaryで管理。同一監視盤配下にある同一「エリア番号+代表バージョン」の改札機プログラムは、
必ず同一である前提で、同一のダイアログに紐づける。

当該ダイアログは、自分のCloseイベントハンドラで、この辞書から自分のエントリを削除する。

「何等かのプログラムがどこにも保持されなくなったとき、この辞書にエントリがあれば、MainForm側から
そのダイアログを閉じる」ということはしない（どこにも保持されていないことの検索が大変なので）。
その代わり、あたらしいModuleInfosを作ったときに、それと同じキーのものがこの辞書に登録されていないか
チェックし、登録されていれば、再描画させる。
基本的に、どこかにModuleInfosが保持されている間（監視盤に保持されている間）は、同じキーの
ModuleInfosを作ることは（受け入れを拒否するため）あり得ないが、どこにも保持されなくなった後、
当該ModuleInfosのダイアログを開きっぱなしで、同一キーのModuleInfosを受け入れてしまうことはあり得る。

→不正な媒体投入があった場合などは、『同一監視盤配下にある同一「エリア番号+代表バージョン」の
改札機プログラムは同一内容である』とは言い切れないので、ハッシュ値もキーに入れることにする。
そうすれば、このシミュレータは、キーが同じである限りProgramModuleInfoを上書きすることが
ないので、表示中のダイアログを更新させる仕組みを作る必要もなくなる（仮に表示を更新させたとしても、
表示のもとになるProgramModuleInfoが書き換わっていることがあり得ず、無意味であるため、
更新不要なものとして割り切るのが妥当である）。

■監視盤プログラム配信・適用を実装。

基本的に改札機プログラムに関する実装を単純化するだけであるが、監視機器側の管理する
保持(1)と保持(2)が無いことに注意。
機械的に改札機と同じ実装にするなら、監視盤内部を仮想監視機器部分と仮想端末部分に
分けるのが楽かもしれないが、グリッドの表示がスマートでなくなると思われる。

--------
2017
--------

チェックボックスのワンクリックで、駅名やコーナー名の列表示有無を切り替え可能にする。
Splitterの位置も同時に変更。

--

配信に関する挙動を強制配信対応後の監視盤相当にバージョンアップ。
マスタ本体やプログラム本体をFTPで受け取って、正常のREQ電文を返すケースでは、
受け取ったファイルの内容を解析して、必ず自分自身の保持情報に反映（上書き）する。
ただし、適用リストに記載されている改札機のうち、既に同名のファイルを
配信済みの機体に対しては、新しくなったファイルを強制配信するわけでは
ない（本物の監視盤も、おそらく、そうであるはず）。

--

適用リストの収納日時をデータ本体の収納日時と別に保持する。

プログラム配信状態画面の場合は、表示列も用意。

マスタ配信状態画面は、表示面積がつらいし、どうせハッシュ値も表示しないし、表示しないでよい。
そもそも、マスタ適用リストは配信が済めば用が無く、実際に保持する機器も限られているし。
余裕があれば、トラッカー風に右クリックメニューで表示列を選択可能にしてもよいが...
→とりあえず、常に表示。

--

これまでは、日時の列は、UpdateDateのみを用意し、当該行に入ってきたり上書きした際の日時としていたが、
「監視盤が受信した日時」と「改札機が受信した日時」に分けて用意する。
「監視盤が受信した日時」は改札機に配信後の各改札機の行にも引き継がせる。
冗長であるが、ユーザの直感に一致するはず。

そして、そうすることで、「改札機プログラム」ウィンドウのキーに「監視盤が受信した日時」を混入させることが可能になる。
これまでのつくりのアプリでも、配信の仕組み上、同一代表バージョンで内容の異なるCABは、ある瞬間に
（１つの監視盤やその配下の）駅務機器内に混在することがあり得ないはずであるし、たとえ、
改札機プログラムウィンドウを開いている間に配信が行われて、そのCABが全駅務機器内から消えた後、
そのCABと同一代表バージョンで内容の異なるCABが配信されたとしても、「改札機プログラム」ウィンドウの
キーにはハッシュ値も含まれるため、（そのようなケースに限り）新しいCABは別のウィンドウで開かれていた
はずであるから、この改造に技術的な意義はない。
しかし、同一代表バージョンで同一内容のCABを強制配信された際は、監視盤は保持しているものを上書きすることに
なっているため、ユーザは（CABの内容が変わっていようが変わっていまいが）上書き前と上書き後のものが
別のウィンドウで開かれることを期待している（それらの内容を目視比較したいと思っている）可能性がある。
よって、技術的には無意味ではあるが、ユーザの感覚を満たす上では意義がある。

--

マスタ配信状態画面の改札機の行にも、適用リストのバージョンなどを表示する。
これは、監視盤がその改札機にマスタ本体を送ることになった際に使用した適用リストのバージョンである。
改札機はマスタ適用リストを保持しない（監視盤は改札機に送信しない）はずであるため、
これまで表示していなかったが、ユーザ（リハーサルや試験の実施者）は、各改札機が
何をトリガーにマスタを受信したのか（マスタを適用することになるのか）を
知りたいかもしれないため、不自然かもしれないが、意味がある。

--

受信した適用リストの内容を保持する。
また、適用リストに関する列のダブルクリックで
「適用リスト」ウィンドウ（モードレスダイアログ）を開き、
適用リストの内容を表示する。

--

適用リストのハッシュ値を表示するための列を用意する。
これは、データグリッドビューがダブルクリックされた際に
「適用リスト」ウィンドウのキーを生成する上でも必要になる。

--

監視盤プログラム配信状態画面の（適用リストと関係ない列の）ダブルクリックで、
「監視盤プログラム」ウィンドウを表示する。
このウィンドウには、
バージョンリスト用の XlsField を用意して、XlsDataGridView で表示させる。
また、TsbCabに出力させたCab内のファイル一覧も表示させる。
表示内容はタブで切り替え可能とする。

--

「改札機プログラム」ウィンドウに、TsbCab出力と
バージョンリスト解析結果のタブを用意。

--

マスタの内容も保持するように改善。
マスタ配信状態画面の（適用リストと関係ない列の）ダブルクリックで、
「改札機マスタ」ウィンドウを表示する。
このウィンドウには、ファイルフッタの解析結果を表示する。

--

改札機が同一バージョンのプログラムを（適用していなくても）受信さえしていれば、
「適用済」を返すよう変更。たぶんこれが実物の改札機システムの仕様と思われる。

--

ポイントポストペイ対応

--

マスタ配信状態を表示しているDataGridView2をダブルクリックして
既に開いている「改札機マスタ」ウィンドウをActivateさせようとしたとき、
アクセス違反が発生したらしき例外がスローされる。

	System.AccessViolationException
	保護されているメモリに読み取りまたは書き込み操作を行おうとしました。他のメモリが壊れていることが考えられます。
	   場所 System.Windows.Forms.UnsafeNativeMethods.CallWindowProc(IntPtr wndProc, IntPtr hWnd, Int32 msg, IntPtr wParam, IntPtr lParam)
	   場所 System.Windows.Forms.NativeWindow.DefWndProc(Message& m)
	   場所 System.Windows.Forms.ToolTip.WndProc(Message& msg)
	   場所 System.Windows.Forms.ToolTip.ToolTipNativeWindow.WndProc(Message& m)
	   場所 System.Windows.Forms.NativeWindow.DebuggableCallback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)
	   場所 System.Windows.Forms.UnsafeNativeMethods.DispatchMessageW(MSG& msg)
	   場所 System.Windows.Forms.Application.ComponentManager.System.Windows.Forms.UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop(Int32 dwComponentID, Int32 reason, Int32 pvLoopData)
	   場所 System.Windows.Forms.Application.ThreadContext.RunMessageLoopInner(Int32 reason, ApplicationContext context)
	   場所 System.Windows.Forms.Application.ThreadContext.RunMessageLoop(Int32 reason, ApplicationContext context)
	   場所 System.Windows.Forms.Application.RunDialog(Form form)
	   場所 System.Windows.Forms.Form.ShowDialog(IWin32Window owner)
	   場所 System.Windows.Forms.Form.ShowDialog()
	   場所 JR.ExOpmg.DummyKanshiban.MainClass.Main() 場所 C:\Users\z35273zz\Documents\運管\EXOPMGw\SRC\Tools\DummyKanshiban\MainClass.vb:行 39
↓
https://support.microsoft.com/ja-jp/help/2892345/system.accessviolationexception-occurs-with-tooltips-in-windows-forms
http://aburasosogu.blogspot.jp/2017/03/vbnetdatagridviewformaccessviolationexc.html

--

媒体投入機能を追加

	左側のデータグリッドで任意の監視盤を選択した状態で
	たとえば「改プロ媒体投入」ボタンをクリックすると
	CABを選択可能なオープンファイルダイアログが開く。
	ここで投入したいCABを選択すれば、監視盤配下の全改札機に
	プログラムの適用までが完了する。
	なお、配信待ちや適用待ちの情報は消すのが妥当と思われる。
	こういった挙動は実機に合わせるのがよいが、もし、配信待ちの末尾に
	キューイングするべき...などとなると、適用中のものや先にキューイングされているもの
	との整合性が保証されないので、クラッシュする可能性があるかもしれない。
	また、その場合、間違いなく適用リストも選択させる必要がありそう。
	適用リストの投入は、どのみち必須かもしれないが。
	実装は簡単だが、実機の仕様を調べる必要あり。

--

プログラム適用時の処理に「動作許可日チェック」を追加

--

バージョンリストに記載されたエリアとファイル名のエリアの比較機能を追加

--

バージョンリストに記載された代表バージョンとファイル名の代表バージョンの比較機能を追加

--

シナリオ(DummyKanshiban).txt において、運管からのプログラムDLL完了直後に余計なプログラム適用処理の呼び出しを記述していたのを削除

--

能動処理のボタンにツールチップを付与

--

監視盤自身が既に保持しているものと同名かつ同内容の改札機プログラムを受信した場合も、
DLLシーケンスの終わり方をFinishWithoutStoringにはしない。
	→ ただし、実機監視盤の動作を想定し、監視盤の保持(2)と同じものが
	既にいずれかの改札機に配信されている場合に限り、
	あらたに受信したプログラムの「代表バージョン」「ハッシュ値」のいずれかが
	監視盤の保持(2)と異なる場合はFinishWithoutStoringにする。
	これは、単純に新しい（これまで保持しているどれとも異なる）世代の
	プログラムを受信したが、それを格納する場所がないため... とみなすことができる。
その後、改札機への配信処理の際、適用リストに記載された適用日が当日以前の全ての改札機を処理対象にし、
改札機が保持しているものと同名（かつ同内容？）ならば「適用済」のDL完了通知を生成する。

なお、実機監視盤のつくりを想像すると、適用リストのバージョンか内容が変わらない限り、
プログラム本体の「適用済」のDL完了通知も作成しないはずである（DL完了通知「要作成」状態にならない）。
シミュレータでは、改プロ配信処理において、適用リストのDL完了通知が「正常」以外（適用済み等）になる場合に、
「改札機へのプログラム本体の配信」や「プログラム本体のDL完了通知の作成」をスキップすることで、これを実現する。
これにより、内容が変更されたプログラム本体を受信した場合も、適用リストが変更されていない限りは、
端末へ配信しないことになる。これは実機監視盤の制限事項と一致するはずである。

--

監視盤自身が既に保持しているものと同名かつ同内容のマスタを受信した場合も、
DLLシーケンスの終わり方をFinishWithoutStoringにはしない。
	→ ただし、実機監視盤の動作を想定し、監視盤の保持(2)と同じものが
	既にいずれかの改札機に配信されている場合に限り、
	あらたに受信したプログラムの「マスタバージョン」「ハッシュ値」のいずれかが
	監視盤の保持(2)と異なる場合はFinishWithoutStoringにする。
	これは、単純に新しい（これまで保持しているどれとも異なる）世代の
	マスタを受信したが、それを格納する場所がないため... とみなすことができる。
その後、改札機への配信処理の際、適用リストに記載された全ての改札機を処理対象にし、
改札機が保持しているものと同名（かつ同内容？）ならば「適用済」のDL完了通知を生成する。

なお、マスタ受信については、適用リストのバージョンも内容も変わらない場合に、
監視盤への受け入れの時点で、改札機別の配信保留キューに入れないようにする。
これにより、内容が変更されたマスタ本体を受信した場合も、適用リストが変更されていない限りは、
端末へ配信しないことになる。これは実機監視盤の制限事項と一致するはずである。

--

東京駅幹幹口エリアの受信可能マスタから北陸のマスタを除去。

--

監視盤の受付対象マスタ種別という概念を用意。
定義にありながら、これに該当しない種別のマスタは、DLLシーケンスの終わり方をFinshWithoutStoringにする。
特に北陸エリアの監視盤は、エリアに無関係なマスタを受信した際に、FinishWithoutStoring で DLL シーケンスを終わらせる。

--

監視盤の受付対象マスタ種別でありながら
改札機の受信可能種別でないマスタについては、
マスタ適用処理において「適用済」のDL完了通知を送信する。
また、その際は、改札機に当該マスタを送信する（そうすることで、監視盤が受信したマスタと
同じものを改札機が保持している体で、バージョン情報を作成する）ように変更。
これは、自動改札機システムと同等の動作をさせるための偽装である。

--------
2017.12
--------

保守系データの編集・蓄積機能
蓄積は、専用のファイルに行う。たとえば別集札データの場合は、%MachineDir\#BesshuData.datに追記する。
蓄積は、UIからだけでなく、StoreFooData要求があった際にも行うようにしておく。（内容の指定法などの課題あり）

--

異常データの編集・送信機能
異常データについては、即時能動送信（電文ファイルを作成してActiveOneを行う）ボタンも用意する。
異常データ電文のファイル作成は、CreateFaultDataPostReq要求があった際にも行うようにしておく。

--

・マスタや上りデータのクリア機能を追加
・シーケンスNoの管理方法を修正
・初回起動時に暗黙に投入されるダミープログラムの受信日時やハッシュ値などを“(不明)”と表示するように変更
・その他UI全般を分かりやすくなるように改善

--

MultiplexEkimuSim から受信するメッセージの仕様変更（Args追加）に対応

--

DirectInstallGatePro 要求を追加（引数でCABファイル名を指定する）
DirectInstallKsbPro 要求を追加（引数でCABファイル名を指定する）

