XlsField の書式に「S」書式を用意する。
elemFormatRadix は -1。
全角文字や空白類もそのまま表示するが、CRやLFやヌル文字は「\r」「\n」「\0」で記述する。
末尾の連続した「\0」は省略する。入力した文字のバイト数が短い場合は、末尾の不足分をヌル文字で埋める。

--

サーバ駆動ULLの対象ファイルは、DummyFoo は読み書き排他モードで更新する。
Sim本体は、排他にかかったら、Busyを返すようにする。

--

異常データのシーケンス番号はグリッドからもってこないようにする。

--

MainFormのDataGridView2について...

保守系データの表示形式は共通（「保守状態」ラジオボタンで表示）とし、
その中の異常データ関連項列（最終異常日時 等）のダブルクリックで
異常データ編集ウィンドウをオープンするか？
それとも、共通部分（「ラッチ状態」ラジオボタンで表示）と
異常データ専用部分（「異常発生状態」ラジオボタンで表示）に分けるか？

→ 「シーケンスNo」が（ユーザの通過で発生する）各種データを紐づけるものであるなら、項目数的に前者がよい。
「シーケンスNo」がデータ種別ごとに管理されるものであるなら、
データ種別ごとに「シーケンスNo」列を表示する必要があるので、後者でもよい。

--

全DummyFoo

	FooDataForm.CreateInitialValueの意味は？
	BaseHeaderSetButton_Clicked などで使用しないなら、用意する必要ないのでは？
	オール０のバイト配列を作った後、FooDataUtil.SetFieldValueToBytes で特別な部分の値を上書きし、
	FooDataUtil.GetFieldValueFromBytes で項目ごとの初期値を取り出せばよいのではないか？
	→ たとえば A20形式の項目の初期値は0x00埋めではなく、0x20埋めなので、そういうわけにはいかない。

	初期化時のマスタや（監視盤になく、本当に空になる場合の）プログラムの受信日や
	各種保守系データの最終発生日時などは、
	現在日時や当日の運用開始時刻ではなく、2000/01/01 00:00:00 か DateTime.MinValue に。

	各種データの編集ウィンドウの上書き保存ボタンで、ファイル全体を上書きするのではなく、
	指定したレコードのみを上書きするように。

	「シーケンスNoクリア」ボタンは「機器状態初期化」ボタンに変更しては？
	シーケンス番号のリセットだけでなく、初期稼動データファイルの作成や、受信データのクリアも行う。
	それにより、新しい機器を検出した際の処理にも流用できるはず。
	また、コマンドとして用意したら、テストの条件を整える上で有用なはず。
	→ 上りデータは端末別に削除できても、配信データはそうはいかなかったり、
	監視機器には残す必要があったり、監視機器用のデータもあったり、
	そもそも、運用を開始して以降は初期状態などという概念がなく、かわりに
	媒体直接投入の機能があったりするわけである。
	よって、上りデータ関連のみを初期化する「データクリア」ボタン（UpboundDataClearButton）にした方がよい。
	マスタはプログラムと違って（個々の端末内または監視機器＋全端末から）消すことも許容できるので、一緒に消してもよい。
	それとも、マスタを削除したい場合は、一度「端末削除」をしてもらう方が一貫性があるか？

--

データに付与するシーケンスNoは1〜UInt32.MaxValueとする。
よって、グリッドに表示するのは「最後に発生した」データのシーケンスNoとし、初期値は0とする。
つまり、データに付与するシーケンスNoは、グリッドに表示している番号＋１とし、
データをコミットした後は、そのシーケンスNoをグリッドに単純にコピーするだけとする。

--

グリッドの最終稼動SEQ.Noや最終稼動処理日時を更新するタイミングは？

案１
上記の更新（編集したデータからのコピー）自体は「窓処に反映」ボタンをクリックするたびに毎回行うことにし、
実際に書き込む値は、稼動データを編集する際（保存する際）にデータに付与する番号で調整する。
すなわち、編集後の稼動データの処理日時の運用日が編集前と変わらなければ、
シーケンスNoも編集前と同じにする。

案２
シミュレータ本体にもコマンドとして公開する「稼動締切」のボタンを用意する。
このボタンにより、管理ファイルの処理日時やシーケンスNoを（グリッドの値をもとに）更新し、
その値をグリッドの最終稼動SEQ.Noや最終稼動処理日時にコピーする。

→ 将来的に異常データの発生に合わせて稼動データを自動で更新する場合を考えると、案２がよい。
このタイミングでなら、全ての端末について処理を行うことが不自然でないため、
#KadoData.dat を #KadoDataTemp.dat にリネームして、機器構成に無いレコードを切り詰めた
（機器構成にしかないレコードを無理矢理追加もした）#KadoData.dat を作りなおすこともできる。

→ 自由度を考えると、編集ウィンドウで「ヘッダ設定」した際のシーケンスNoやランダム更新後のファイルのシーケンスNoは
「グリッドの値 + 1」とし、グリッドの値の更新（ファイルからの読み直し）を稼動データ収集完了のタイミングのみとするのがよい。

--

稼動データ編集ウィンドウ
	稼動データグリッドの初期値は、管理ファイル（#KadoData.dat）から読み込む（このときはファイルにロックを掛ける必要は無い）。
	「窓処に蓄積」ボタンで、管理ファイルに書き戻す（読みとりロックつきで）。

	野良ファイルを読み込んだ場合に、ワンクリックで再設定したい項目があるとすれば、基本ヘッダだけのはず。
	なので、「前半設定」ボタンはいらない。
	ただし、日付のみのFormatにしたSelectDateTimeDialogで基準日を入力させて、
	開始日時はその前日の運用開始時刻、点検日時はその前日の所定時間（INIのDeafultKadoTenkenTimeに持たせる）、
	処理日時と集計終了日時は現在日時にしてもよい。

	管理ファイルが読めなかった場合の救済処置として、機器IDなどから初期値を作って表示することになるが、
	これは、MainForm 側における機器検出時の処理と共通化できるはずであるため、ExUtility に実装する？
	MyUtility の GetNextSeqNumber() や MainForm の GetStationOf() などもこのクラスに移すとよい。

	処理日時自動更新チェックボックスにチェックが入っていたら、処理日時だけでなく、集計終了日時も更新させたい。

	稼動データだけクリアしたい場合もあるかもしれないので、集計リセットボタンがあってもよい。

--

エラーコードから「異常項目 表示データ」を取得するための専用のセクション（FaultDataErrorOutlines）をINIに用意する。
エラーコードから「可変表示部 表示データ」を取得するための専用のセクション（FaultDataErrorDetails）をINIに用意する？ → 可変であり、改札機などは投入券の情報なども入れるためやめた方がよい。
エラーコードごとのエラーレベルを取得するための専用のセクション（FaultDataErrorLevels）をINIに用意する。
エラーレベルから「処置内容 表示データ」を取得するための専用のセクション（FaultDataLevelGuidances）をINIに用意する。
エラーコードのセクション（FaultDataErrorCodeItems）の各Valueは、「異常項目 表示データ」として使用しない。かわりに「異常項目 表示データ」が同一になるエラーコードも区別できるような文言にする。
