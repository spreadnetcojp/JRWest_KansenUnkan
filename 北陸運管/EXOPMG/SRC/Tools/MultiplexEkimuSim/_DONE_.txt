--------
2015
--------

//UiState を ExOpmgMultiplexEkimSimState.xml にシリアライズ

//各 DoEvents() の中で実行されては困る処理を洗い出す。
//または、DoEvents() をできる限り使わないようにする。
//　少なくともいつまで続くかわからないことを
//　イベントハンドラのなかで繰り返す（手抜きの）ためだけに
//　DoEvents() を使うのはやめる感じで。
//　たとえばDoScenario()におけるDoEventsの呼び出しは、
//　nextExecIndexOfScenarioに加えて、nextExecIndexOfClientsを
//　Formのメンバに用意すれば、間違いなく排除できるはず。
//→とりあえず洗い出してみて、問題ないように修正した。

//あり得ないはずではあるが、Telegrapher の停止を検出した際は、
//メインスレッドでメッセージボックスを表示し、メッセージボックスを閉じた際に
//Telegrapher を再起動するようにする（せっかく再起動できるようにしてあるので）。
//現状、それを検出し得るケースは、ソケットへの内部メッセージ書込みで長時間ブロックされて
//「気づいてしまった」場合だけであるが、積極的な死活監視を行ってもよい。

//文字列内機器コードシーケンス展開メソッドを作成する（ファイル名内機器コードの置換機能）
//　文字列の中の特殊な表現（%R, %3R, %S, %3S, %C, %4C, %U, %2U 等）を
//　一緒に渡された EkCode の要素に置き換えて、新たな文字列を出力する。
//　UI中のファイル名等は、この書式で記述されているものとみなし、
//　必ずこのメソッドで変換してから使用する。
//→単純に EkCode.ToString(対象文字列) でよさそう。

//Byte配列内の機器コード要素にパッチをあてるメソッドを作成
//　Byte配列、位置、書式（H2, H1, D4, D3, D2, PD2, PD1, A4, A3, A2 等、表現とバイト数）、
//　コード種別（R, S, C, U）および、EkCodeを引数に呼び出すと、Byte配列の内容が書き換わる。
//　UIにおいて、ファイルのパスを記述する場所の横に、パッチ指定文字列（「位置-書式-コード種別, 位置-書式-コード種別, ...」の繰り返し）を記述する場所を設ける。
//　ただ、たとえば監視盤シミュレータとして動作させている場合に、渡すEkCodeは監視盤の機器コードになるわけで、
//　ほんとうは監視盤配下の改札機の機器コードにした場合はどうにもならない...
//　そう考えると、先述の対応で機器コードからファイル自体を選択できるようにしておくだけで、必要十分か...
//→やめ

//能動的処理の実行ボタン押下時に、ClientDataGrid で選択されている Client のみ実行を行うようにする。
//　受動的処理のタブが前面にある際は、誤認のないよう、ClientDataGrid の色を変える。
//　「接続切断」タブ（能動的処理のタブ）を用意し、「接続」ボタンと「切断」ボタンは、ここに入れる。
//　「基本」タブにある「自動で開局」のチェックボックス、「接続初期化要求」ボタン、「日時要求」ボタンは「接続切断」タブに移動。
//　「基本」タブは「キャプチャ」タブに改名し、末尾に移動。

シナリオに機器コード列を追加。
　線区コード-駅順コード-コーナーコード-号機コードの書式で記述する。
　コード 0 はワイルドカード。たとえば全 Client を指定する場合は 0-0-0-0 と記述。
　「シナリオ」タブは ClientDataGrid の選択と無関係にする？
　　→ 「旧シナリオ」タブと「新シナリオ」タブを用意するか、
　　ClientDataGrid で選択されていない号機については、たとえ個別指定されていても
　　スキップする仕様でよさそう。

「Nakを返信」のチェックボックス等を種別ごとに設定可能にする（DataGridView に入れる）？

能動的電文送信や能動的ULLのタブにも DataGridView を配置し、その各行に現行の全コントロールを入れる？
これにより、よく使うデータの設定を常備しておき、いつでも実行を可能になるが、複雑すぎないか？


■シナリオの仕様を改善

実機のログからシナリオを生成するツール。
無理なら運管サーバシミュレータを作り、受信した電文全体やファイルを都度保存できるようにして、監視盤や窓処の相手をさせてみる。
シミュレータといっても、スケジュールに沿った能動的動作や、運管端末からの要求に応じた能動的動作ができないと、
採取できるものが限定的になってしまうので、実機用運管サーバアプリにキャプチャモードを用意するのが現実的である。
その方が、開発のボリュームも少ない。実機の仕様変更に合わせたメンテナンスも不要になる。
「接続試験の際に、その設定を ON にしておけば、採取が完了する」というメリットも。

シナリオの中で、返信するACK電文データ部やファイルの変更を実行できるようにしないと、実機と同等な動作の試験を自動化することは不可能。
シナリオの中で、NAK電文を返信できるようにもするべき。シナリオ自動生成（採取）ツールでは、コマンドコードがACKではなくNAKの場合に、
事由コードと事由文言を抽出してシナリオに記述する。

高速に自動試験を実行できるようにするには、シナリオに指定種別の受動的シーケンス完了を「待つ」という行を記述できる方がよい。
たとえば、種別が「マスタDLL」のシーケンスを待つ行を記述し、その次に相対時間 0ms で、マスタDL完了の ActiveOne を記述するなど。
これにより、所定の時間に収集が行われることの確認等も簡単になる？（所定の時間にシナリオ実行が終われば「良」とするなど）

■もっと汎用的に、シナリオ内イベントマップという概念を導入し、シナリオの各行にはイベントハンドラを登録するコマンドを記述できるとよさそう。

たとえば、以下のような感じで「指定したデータ種別の指定オフセットが指定バイト列の電文を受信した際に行うべき処理（NAKや返信ファイル）」を登録する。
+200,070-001-0063-01,RegHandlerOnRcv,40,230,00-A0-23,PassiveDll,Nak,,,
PassiveGet タブや PasivePost タブや PassiveUll や PassiveDll タブの設定を号機別にシナリオ内で行えるようにするイメージ。

たとえば、以下のような感じで「指定したデータ種別のシーケンスが指定した内容の電文で終了した時に行うべき能動処理」を登録する。
+200,070-001-0063-01,RegHandlerOnSeqEnd,40,230,00-A0-23,ActiveOne,%3R%3S_%4C_%2U\DL完了,,,,

そのためには、シナリオの実行を各電文送受信スレッド起点で行うようにしなければならない。
今と全く違う設計になるが、その方が、タイマの精度もよいし、完全な同時実行も期待できるので、瞬間負荷の試験を考えるとむしろ良い。
運任せであることにはかわりないが、今の実行方法だと、たとえ運がよくても同時実行は殆ど期待できない。
なお、別の時刻を指定した異なるクライアントにおける処理の実行順序については、今でも（最終的には異なるスレッドで行うわけであるから）
保証されないし、そもそも実運用上も複数クライアントが同期をとることなどあり得ないので、保証される必要はない。
電文送受信スレッドは、シナリオ内にある自分以外を対象とした行は、単純に読み捨てればよい。
シナリオ内に記述する実行機器のコードを全て0-0-0-0（全号機で実行）とし、
クライアントごとに異なるシナリオファイルを渡してもよい（ファイル名内機器コードの置換機能で可能）。

電文送受信スレッドで実行するとなると、UI的に、実行/中止ボタンの切り替え制御が問題になりそうだが、
終わりを知らせるだけなので、LineStatusと同じような共有メモリを用意すればよい。
少なくとも、イベント待ちをメインスレッドで行うなら、電文送受信スレッドが、すべてのイベントについて、
毎回メインスレッドに知らせる（双方向のスレッド間通信の）必要性が生じるわけであるから、それより全然よい。
【案１】
　共有メモリへの書込みを電文送受信スレッドもメインスレッドも行う方式。
　・共有メモリで管理する状態は、「停止中」「実行中」の２種類。
　・メインスレッドは、実行ボタンが押下された際、共有メモリを「実行中」に変更してから
　　電文送受信スレッドに開始要求を送信し、実行ボタンを中止ボタンに変更する。
　　また、共有メモリを監視するためのタイマを開始する。
　・メインスレッドは、中止ボタンが押下された際、電文送受信スレッドに終了要求を送信する。
　　ただし、ここでは勝手に共有メモリの変更は行わない。
　・電文送受信スレッドは、中止要求を受信した際、シナリオの実行を終了する。
　　既に最後まで実行を終えていたら、単に中止要求を読み捨てる。
　　次に受信する可能性のある開始要求との処理順序を入れ替えないために、これは必須である。
　・電文送受信スレッドは、シナリオの実行を（自らまたは、中止要求により）を終えたら、
　　共有メモリを「停止中」に変更する。
　・メインスレッドは、タイマハンドラで共有メモリが「停止中」になったのを検知した際に、中止ボタンを実行ボタンに変更する。
　　なお、選択されていないクライアントも含め、全てのクライアントに関する共有メモリが「停止中」にならない限り、
　　中止ボタンは実行ボタンに変更しない（選択されていないクライアントもケアするのは、開始時と選択状態が変わっている可能性があるため）。
【案２】
　共有メモリへの書込みを電文送受信スレッド側のみが行う方式。
　・共有メモリで管理する状態は、「開始要求待ち」「実行中（終了要求待ち）」「実行後（終了要求待ち）」の３種類。
　・メインスレッドは、実行ボタンが押下された際、電文送受信スレッドに開始要求を送信し、実行ボタンを中止ボタンに変更する。
　　その際、共有メモリが「開始要求待ち」以外になるまで待ってから、共有メモリを監視するためのタイマを開始する。
　・電文送受信スレッドは、自らシナリオの実行を終えた場合は、共有メモリを「実行後（終了要求待ち）」にする。
　・メインスレッドは、中止ボタンが押下された際または、タイマハンドラで共有メモリが「実行後（終了要求待ち）」状態に
　　なったのを検知した際に、終了要求を送信する。
　・電文送受信スレッドは、中止要求を受信した際、シナリオの実行を終了し、共有メモリを「開始要求待ち」にする。
　　既に最後まで実行を終えていたら、単に、共有メモリを「開始要求待ち」にする。
　　次に受信する可能性のある開始要求との処理順序を入れ替えないために、中止要求を残したりはしない。
　・メインスレッドは、タイマハンドラで共有メモリが「開始要求待ち」状態になったのを検知した際に、中止ボタンを実行ボタンに変更する。
　　なお、選択されていないクライアントも含め、全てのクライアントに関する共有メモリが「開始要求待ち」状態にならない限り、
　　中止ボタンは実行ボタンに変更しない（選択されていないクライアントもケアするのは、開始時と選択状態が変わっている可能性があるため）。
いずれの案にしろ、ユーザはクライアント単位で、シナリオ実行中か否かを知る必要があるだろうから、
ClientDataGridView における「状態」表示も、「シナリオ状態」と「接続状態」を表示した方がよさそう。
そうなると、接続・切断と同じように、個別にシナリオの開始や中止ができた方が使いやすいかもしれないので、
「実行」ボタンと「中止」ボタンを分けた方がよいかもしれない。
「実行」ボタンが押下されても、選択中のクライアントの共有メモリが「停止中」でない限りは、
そのクライアントについては何もしない感じで。

もう１つの懸案が、Connect と Disconnect を（シナリオの場合だけ）電文送受信スレッドで行うことに
問題がないかである。LineStatus の読み書きの方式は、これを見越して【案２】のような方式にしてあるので、
大丈夫なはずである。問題は、ClientDataGrid の状態列を「接続中」や「接続失敗」にできそうもない
ということ。シナリオから Connect した場合はいきなり「開局中」になり、シナリオからの
Connect に失敗した場合は「接続失敗」でなく「切断」になるという割り切りでよいのか？
それに、メインスレッドからみて、Initial だった LineStatus が、接続要求を送信していないのに
勝手に Connected に変化することがあり得るという制御上の大問題も。
もう、接続失敗は ClientDataGrid で確認できるわけであるし、接続失敗時のメッセージボックス表示はあきらめて、
接続ボタンや切断ボタンが押下された際の Connect や Disconnect も、各電文送受信スレッドで行う方がよいのではないか。
全クライアントで同時実行したり、無駄に同時失敗したりしても、実害もおそらくない。
LineStatus 列挙体には ConnectWaiting（接続中）、ConnectFailed（接続失敗）を追加する。

それと、シナリオの繰り返しの設定は、UIから除去しなければならない。
かわりに、シナリオの中に、指定行にジャンプするというコマンドを記述可能にする。

電文受信時イベントの発動条件を指定するのに「比較対象バイト列を記述する」とか、あんまりなので、
たとえば、データ種別と変換先クラス名（EkMasProDllReqTelgram）と、そのプロパティ名
や比較演算子や論理演算子を用いた式で記述するようにする？（プロパティ名から
実際のプロパティ値を取得するのは Reflection でいけるが、それ以外は簡易インタプリタを作る必要がある）
それとも、正規表現を記述できるようにしておけばよい？
ハンドラで実行する処理を記述するのに、受信データの一部分を、違う型に変換した上で、
送信データに転記したいかもしれないが、そういった処理の記述方法も考えなければならない。
もう、シナリオの一部を vb.net の文法で記述し、それをもとに、特定名称のクラスの
特定名称のメソッドがあるような、完全な vb.net の一時ファイルを生成し、子プロセスで
DLL にコンパイル後、それを動的ロードして、そのメソッドを実行してもよいかも。

→そもそも、本物の駅務機器と同じロジックで動く必要はなく、試験では、想定どおりの（過去の運管サーバから
採取しておいたのと同じ）電文がきた場合にだけ、実機駅務機器から採取しておいたデータを返信できればよいわけである。
想定と違う内容のデータがきた場合は、むしろ、期待していないデータがきたことをユーザに伝えるべき。
よって、比較対象ファイルのパスと、そのファイルと同じ大きさのマスク用ファイル（比較しない箇所のバイト値を00、
全ビット比較するべき箇所のバイト値をFFにしてあるようなファイル）のパスを指定するとかで、必要十分と思われる。
想定していない受信電文のシーケンスが発生した場合、電文送受信スレッドはシナリオの実行を中止し、
ScenarioStatus を Aborted とし、ClientDataGrid のシナリオ状態に「異常」と表示すればよい。
シナリオ開始時は、プロトコル仕様上許されるあらゆるシーケンスを許容し、
シーケンスハンドラに何か登録を行うと、それと同じデータ種別のシーケンスは、登録されている
もの以外全てを「異常」とみなすようになる感じで。
同じ号機の同じデータ種別について、正常とみなせるデータをいくつでも登録できるような仕様にしておく。
正常とみなすデータを受信した場合に何を実行するかは、単純かつ柔軟に指定できるように、
ジャンプ先の行を指定する仕様がよい。
シナリオファイルの末尾がシナリオの終わりとは限らない感じになるので、
シナリオを正常終了するためのコマンドや、異常終了するためのコマンドも記述可能にする。
行の指定は、行番号ではなく、ラベルで行えるとよい感じ。

シナリオ自動生成（採取）で機械的に大量の電文ファイルができてしまうことを考えると、
採取モードのときの運管サーバの負荷を考えても、ユーザにとってのシナリオの管理のしやすさ的に考えても、
シナリオには、ファイル名ではなく、ファイルの内容を16進で記述可能にした方がよい？（それらの電文はシナリオ従属であり、再利用しにくくても構わないし）
現状のファイル名の部分が「file:」で始まればファイル名とみなし、「bytes:」で始まればファイル内容とみなすなど。

//シナリオ各行の実行タイミングを絶対YYYYMMDDhhmmssfffや相対ミリ秒だけでなく、相対日数+hhmmssfffで記述できるようにした方が、
//自由な（いろいろな）日で自動試験を流してみることができるのでよいかも。
//ただ、どのみちデータの中にある日付はケアできないので、やめといた方が無難か。
//→やめ

■シナリオ内イベントマップのリアルタイムな閲覧を可能にする？

それができないと、試験において、そもそもシナリオが正しいのか否かの確認が大変。

メインウィンドウの受動的シーケンスのタブにあるグリッドに表示するわけではない。
シナリオ実行中に登録したり登録解除するのは、通常のイベントマップとは別の
「シナリオ内イベントマップ」に対してである。よって、メインウィンドウの
グリッドは関係ない（参照するという意味では関係あるが、参照したくないシナリオの
ために、DisableDefaultPassiveUllHandlers のようなコマンドも用意する）。
理由は以下のとおり。
　・メインウィンドウのグリッドをシナリオ内から変更できてしまうと、
　　シナリオを電文送受信スレッドで実行する新設計では、電文送受信スレッドを起点として、
　　メインウィンドウのコントロールを変更する必要が生じてしまう。
　・メインウィンドウのグリッドで号機別の複雑な設定を表示しても、
　　わかりにくいし、ここを変更されると、シナリオ実行後に戻すのが大変。
　・メインウィンドウのグリッドには、普段、全号機共通で、プロトコル仕様に違反しない
　　シーケンスが確実に完了する設定をいれておきたい。
　・蛇足であるが、複雑な設定を可能にすることを視野に入れ、メインウィンドウのグリッドに
　　対応するコレクションを Dictionary から DataTable に変えることは構わない。
　　性能が落ちるかわりに、複数の行を抽出するクエリを行えるようになるので、
　　ワイルドカードつきの号機別設定を管理可能にする場合には、必須といえる。
　　しかし、そうしたところで、その DataTable を DataGridView の DataSource に
　　セットできる（楽をできる）ようになるわけではない。この DataTable は
　　電文送受信スレッドで参照されるため、変更する際に事前に特定オブジェクトを
　　対象にした SyncLock を行う等の実装が必要だからである。

ClientDataGridView の行をダブルクリックすると、メインウィンドウとモードレスな
クライアント専用ウィンドウを表示する仕様にする。
　・そのウィンドウには、当該クライアントが反応するイベントの一覧を表示する。
　・シナリオ内イベントの登録や登録解除が行われた際は、リアルタイムに一覧を更新する。
　・そのウィンドウのメッセージループは、電文送受信スレッドの子スレッドで動作させる。
　　スレッド間メッセージの流れは以下のような単方向とする。
　　　メインスレッド → 電文送受信スレッド → クライアントダイアログスレッド

単純に、電文送受信スレッドのログをみてわかるようにしておけばよいか？


■ノーマルEkimuSimへの水平展開

//周期 -> 間隔
//Rate -> Interval

//ScenarioExecInterval 追加（シナリオ繰り返し機能追加）
//Scenario の日時書式変更（区切り文字追加、１行目の相対時間の許容）

//「ログを表示」のチェックボックスを追加

//UiStateのシリアライズ機能追加
//「ActiveUll」「ActiveOne」「シナリオ」タブの状態も UiState に追加し、そちらを主に（初期値もDesignerではなくUiStateClassに記述）


■外部コマンドとの連携

・シナリオの中から、非常駐exeを子プロセスとして実行し、終了を待つ。

・負荷は高いが手軽である。

・基本的に単純な編集用exeを実行する。

・シミュレータとexeのインタフェースはファイルとする。

・能動的シーケンスの前の専用の行でexeを実行して能動的シーケンス用のファイル
　１つまたは複数を作成するニーズと、
　受動的シーケンスの途中で、運管サーバから受信したデータをインプットとして、
　送信データ（ContinueCode）または送信ファイル１つを作成するニーズとがある。

・前者のニーズをみたすために、シナリオに以下のような行を記述可能とする
　　<機器コード> CallExtCmd <コマンド名>;<コマンド引数>;<最大待機時間>

・後者のニーズをみたすために、ParamTypeがMustFilePathやContinueCodeのパラメータには、
　以下を記述できるようにする。
　　FromExtCmd:<コマンド名>;<コマンド引数>;<最大待機時間>

・前者のニーズを考えると、「あるコンテキストにて、CallExtCmdの行を実行してファイルを作成した後、
　待機が必要になる行で待ってから（他のコンテキストに割込まれてから）、その先の行で
　ファイルを参照するケース」を想定しなければならない。
　ゆえに、１つのTelegrapherで複数の子プロセスを同時には実行することはなくても、
　子プロセスの作業ディレクトリはコンテキストごとに用意する。
　駅務機器は、運管からファイルを受信後、DL完了通知を送信する前に、別のファイルを受信した
　場合であっても、両方のファイルに対して必ずDL完了通知を送信するはずであるが、
　この仕様によって、そのような動作も簡単にシミュレートできる（RegPassiveDllProcの行の
　「FromExtCmd:」に記述した外部コマンドで、DL完了通知のもととなる情報をコンテキストの
　作業ディレクトリに保存しておき、それぞれのコンテキストにおいて、登録しておいたProcで、
　当該コンテキストの作業ディレクトリにあるファイルをもとにしたDL完了通知を送信すればよい）。
　なお、外部コマンドは、同一号機に関しては同時に実行されることはないので、作業ディレクトリの
　１つ上のディレクトリ（号機別のディレクトリ）に、コンテキスト非依存の情報
　（たとえば最後に受信した部材のバージョン情報）などを保存してもよい（プロトコルが使う
　ファイルと被らないようにファイル名の先頭は「#」を推奨）。

・具体的には、下記のディレクトリを作業ディレクトリとして子プロセスを実行する。
　<シミュレータの作業ディレクトリ>\TMP\<機種名ディレクトリ>\<号機別ディレクトリ>\#<コンテキスト番号>

・RegPassiveUllProcで登録したハンドラで応答する場合も、正しい作業ディレクトリで外部コマンドを
　実行させることができるよう、その段階で新規コンテキストを作ってしまうようにする。

・子プロセスは、作業ディレクトリのパス名や、号機別ディレクトリ（作業ディレクトリの親ディレクトリ）に
　あるファイルから、情報を取得する。子プロセスが参照できる情報には、具体的に以下のようなものがある。
　　[1] 模擬時刻
　　　　　システム時刻そのもの
　　[2] 模擬機器の識別コードや駅名やコーナー名や部材エリアコード
　　　　　号機別ディレクトリにある「#Machine.csv」から参照可能
　　　　　識別コードは作業ディレクトリのパス名からも抽出可能
　　[3] 模擬機器の配下にある機器の識別コードや駅名やコーナー名や部材エリアコード
　　　　　号機別ディレクトリにある「#TermMachine.csv」から参照可能（自分が窓処の場合は無い）
　　[4] 最新の受動的GETシーケンスのREQ電文（PassiveGetシーケンスの途中で参照することを想定）
　　　　　号機別ディレクトリにある「#PassiveGetReq.dat」を参照可能（無い場合あり）
　　[5] 最新の受動的ULLシーケンスのREQ電文（PassiveUllシーケンスの途中で参照することを想定）
　　　　　号機別ディレクトリにある「#PassiveUllReq.dat」を参照可能（無い場合あり）
　　[6] 最新の受動的DLLシーケンスのREQ電文（PassiveDllシーケンスの途中で参照することを想定）
　　　　　号機別ディレクトリにある「#PassiveDllReq.dat」を参照可能（無い場合あり）
　　[7] 最新の受動的DLLシーケンスで受信したデータや適用リスト（PassiveDllシーケンスの途中で参照することを想定）
　　　　　号機別ディレクトリにある「#PassiveDllReq.dat」内に名前が記述されたファイルを参照可能（無い場合あり）

・性能を落とさないために、上記の[4]〜[7]は、必要最小限のタイミングでしか更新しないので注意。
　たとえば「#PassiveGetReq.dat」は、「FromExtCmd:」か「FromExtAppFunc:」（後述）が指定された
　「WaitForPassiveGet」の行が実行される際や、同様の指定がされた「RegPassiveGetProc」で
　登録された条件が満たされた場合にしか、更新しない。
　よって、たとえば配信されたものに合わせたDL完了通知やバージョン情報を作成したい場合、
　CallExtCmdで呼び出した外部コマンドは、「#PassiveDllReq.dat」や、「#PassiveDllReq.dat」に
　記述されたファイルを参照するべきではない。「FromExtCmd:」を指定した「RegPassiveDllProc」を
　事前に実行して、受動的DLLの際に任意の外部コマンドが呼ばれるようにしておき、そのコマンドにおいて、
　任意の記憶場所に配信結果や模擬装置が保持する部材（および適用済みの部材）の情報を記憶し、
　DL完了通知やバージョン情報を作成する際は、それをもとに作成を行うべきである。

・後者のニーズの子プロセスは、終了するまでに作業ディレクトリ直下に「ExtOutput.dat」を作成する。

・シナリオに記述するファイル名には、現在のコンテキストの作業ディレクトリのパスに
　置き換わるエスケープシーケンス（%ContextDir）や号機別ディレクトリのパスに
　置き換わるエスケープシーケンス（%MachineDir）を記述可能にする。


■外部常駐プロセスとの連携

・シナリオの中から任意のMSMQに任意のメッセージを送信し、返信を待つ。

・各Telegrapherがデータ送信の頻度で子プロセスを作成する方式に比べれば低負荷。

・実機相当の（状態をもった）業務処理を実現したいのであれば、
　都度呼び出される非常駐プロセスで実現するよりも、いくぶん簡単かもしれない。

・ただし、（ユーザの操作を受けた）外部常駐プロセスからの要求に応じて
　シナリオで能動的シーケンスを実行...といった機能（RegExtEventProcのような
　行で、外部常駐プロセスから受信した要求をハンドリングする機能）は想定しない。
　能動的動作のトリガが外部にある時点で、それはもはやシナリオではない。
　それを行うなら、はじめにシナリオありきで環境を考えるのではなく、
　外部常駐プロセスにおいて、シナリオ生成、シミュレータに登録、シミュレータに
　実行を要求...という外部常駐プロセス中心の環境を考えるべきである。
　ストレートに、外部常駐プロセスの中でClientTelegrapherを継承した
　オブジェクトを用いて通信を行うのが、最も簡単である。

・MSMQに送信するのは、「要求する処理を指定する文字列」と「作業ディレクトリのパス」だけとし、
　他の情報は、CallExtCmdなどと同じく、ファイルで受け渡す。

・CallExtCmdと同等の外部常駐プロセス相手の行は、以下の書式とする。
　　<機器コード> CallExtAppFunc <メッセージキューのパス>;<処理を指定する文字列>;<最大待機時間>

・ParamTypeがMustFilePathやContinueCodeのパラメータには、
　以下を記述できるようにする。
　　FromExtAppFunc:<メッセージキューのパス>;<処理を指定する文字列>;<最大待機時間>

・シミュレータが待つMessageはACKではなく、アプリケーションが作成した応答メッセージとする。
　つまり、AdministrationQueueやAcknowledgeType（PositiveReceive）を設定して、
　システムに返信させる（受信側アプリは「m = q.Peek()」「結果のファイルを作成」
　「q.ReceiveByLookupId(m.LookupId)」を行う）のではなく、
　ResponseQueueを設定して、アプリに返信させる（受信側アプリは「m = q.Receive()」
　「結果のファイルを作成」「m.CorrelationId = m.Id」「m.ResponseQueue.Send(m)」を行う）。
　そうする理由は、以下の２点。
　　(1) 外部プロセスのインスタンスを複数起動し、同一のMSMQを使わせてしまった場合も、正しく動く
　　(2) 後者の方法なら、応答に駅務機器識別コードを入れられる。
　　　　つまり、シミュレータ側において応答受信用MSMQをメインスレッドだけが扱うような
　　　　実装を行う場合に、都合がよい。

・応答受信用MSMQは、スレッド（シミュレートする駅務機器）ごとには用意しない。
　窓処が200台くらいある場合にもったいないので。

・応答受信用MSMQにアクセスするためのMessageQueueオブジェクトも、スレッド
　（シミュレートする駅務機器）ごとには用意しない。
　また、１つだけ用意したMessageQueueオブジェクトを各Telegrapherのスレッドで
　使いまわすようなこともしない。
　１つだけ用意したMessageQueueオブジェクトから、メインスレッドだけが
　応答メッセージ取り出しを行うようにする（応答メッセージを取り出した
　メインスレッドは、応答の駅務機器識別コードが示すTelegrapherに対し、
　応答のCorrelationIdを、内部メッセージ（ExtAppFuncEndNotice）で
　通知する）。

  複数用意しない理由は以下の２点。
　　(1) MessageQueueオブジェクト１つあたりのリソース使用量は不明であり、
　　　　殆どの機能がMSMQ側にあるなら微々たるものかもしれないが、
　　    やはり、もったいない。
　　(2) MessageQueueオブジェクトをスレッドごとに用意すれば、スレッドセーフと明記されていない
　　　　ReceiveByCorrelationIdメソッドを各スレッドで実行することができるので、メリットが
　　　　あるように思えるかもしれない。しかし、そうしたところで、ReceiveByCorrelationIdの
		内部では、Peekで待って、何か受信したらCorrelationIdを調べて、合致したら
　　　　Receiveして戻るだけのようである（その証拠にタイムアウト値の意味が非道なことに...）。
　　　　つまり、何か受信するたびに、応答を待っている全スレッドが実行状態になってしまう。

  メインスレッドだけで扱う理由は以下の２点。
　　(3) .Net Framework4 まではPeekやReceiveがスレッドセーフのようなので、
　　　　それを使ってスレッドセーフなReceiveByCorrelationId相当を実装すれば、
　　　　１つのMessageQueueオブジェクトを使って、複数のスレッドで応答受信待ちを
　　　　行うことができる。しかし、何か受信するたびに、応答を待っている全スレッドが
　　　　実行状態になってしまうのは、前述したとおりである。
　　　　また、.Net Framework4.5 では、GetAllMessagesメソッドだけがスレッドセーフ
　　　　ということになっており、開発時点の旧バージョンでのみ動くような
　　　　しょっぱい実装をするわけにはいかない。
　　(4) 外部常駐プロセスからの応答を待っている際に、シナリオの「停止」ボタンを
		クリックした場合の反応がよくなるはず。
　　　　各Telegrapherは、たとえ外部常駐プロセスからの応答待ち状態であったとしても、
　　　　ScenarioStopRequestを受信したら、シナリオを中止してしまってよい。
　　　　たとえ次のシナリオを実行している最中に、過去のExtAppFuncEndNoticeを
　　　　受信したとしても、それに害はない（CorrelationIdが望んでいる値と
　　　　違うので、読み捨てるだけである）。

　ちょっと複雑化するが、業務処理を実装するためのProcOnFooBarの中で
　InternalMessage.GetInstanceFromSocket() を使って内部メッセージを読取り、
　ScenarioStopRequestでない場合は、
　ScenarioEnv内に新設するParentMessageQueueにAddLastして、
　RootTimerを起動する。
　ProcOnTimeout()でParentMessageQueueをチェックし、何かあれば、
　デリゲートでMyTelegrapherのProcOnParentMessageReceive()を呼び出す。
　このようなことをしても、内部メッセージのハンドリング順序が送信順序と合致するのは、
　Looperがソケットへの着信よりもタイマのタイムアウトを優先して処理しているおかげである。
　悪く言えばLooperの内部設計に依存しているので注意。

--

シミュレータ本体が、運管に対する送信に失敗した場合も、
外部常駐アプリの状態を完全に制御できた方がよい。

そのためには...

・TryActiveOne や TryActiveUll は、送信が成功した時点で、ファイルを消すようにする。
　→ ActiveOne, ActiveUll, TryActiveOne, TryActiveUll 全てに、成功後にファイルを消すか否かを選択するための引数を追加
・外部常駐アプリは、機器別ディレクトリの直下に、送信したいファイルを作成する。
　機器別ディレクトリの直下で、未送データ（というか送信失敗データ）を管理する感じ。
・外部常駐アプリは、DL完了通知のような、レコード単位で送信するデータを、
　レコード単位で枝番付きの名前でファイルを作成する。
　その際、過去の送信失敗データと被らないような枝番のものを作成する。
・外部常駐アプリは、明細データのように、複数レコードの入った１つのファイルを
　任意でないタイミングでしか送信できないものについては、
　過去の送信失敗レコードが格納されている所定名称のファイルに、あらたに発生した
　データを追記する。

多数の枝番に対応できるように、シナリオ内の（読み出し対象な）ファイル名には
ワイルドカードを記述できた方がよい。
ワイルドカードだとあまりにも脆弱なので、正規表現の方がよいかもしれない。

受動的シーケンスで送信したデータの削除は、シーケンスを完了させたシナリオが、
外部常駐アプリにデータ削除要求（件数指定あり）を行うようにし、
外部常駐アプリはそれを受信した際にのみデータを削除すればよい。
受動的シーケンスによるデータ送信自体、UIからはやりようがないので、それでよい。

--------
2017.12
--------

受動的GETや受動的ULLのためにローカルファイルを読み取る際に、当該ファイルが
他のプロセスによりロックされている場合は、
３回リトライを行い、それでも読めないなら BUSY の NAK を返信するようにした。

--

シナリオの実行時、RegPassiveFooProcやWaitForPassiveFooから
静的に指定されたファイルが実在しない場合は、
GUIで指定されたファイルが実在しない場合と同様に、
NO DATA の NAK を返信するようにした。

--

シナリオの文法を下記のように拡張した。
	CallExtCmdステートメントやFromExtCmdの<コマンド引数>にセミコロンを入れることができるようにした。
	CallExtAppFuncステートメントやFromExtAppFuncの<要求内容>にセミコロンを入れることができるようにした。
	<要求内容>がセミコロンで区切られる場合、最初の要素が要求名（Func）とみなされ、残りの要素は要求の引数（Argsの要素）とみなされる。

--

シナリオにおいて下記の部位も展開対象文字列とした。
	RegFooBarステートメントの第１パラメータ（登録番号）
	UnregFooBarステートメントの第１パラメータ（登録番号）
	CallExtCmdステートメントの<コマンド名>や<コマンド引数>
	CallExtAppFuncステートメントの<MSMQ名>や<要求内容>
	FromExtCmdの<コマンド名>や<コマンド引数>
	FromExtAppFuncの<MSMQ名>や<要求内容>

--

展開対象文字列の仕様を下記のように拡張した。
	%Iや%2I（2は任意の数字）は、実行主体となる監視機器の管理番号（シミュレータがロードした機器構成の中での項番）に置き換わるようにした。
	%TIや%T2I（2は任意の数字）は、端末機器の管理番号（実行主体となる監視機器内における項番）に置き換わるようにした。

--

シナリオから TryActiveOne や TryActiveUll を実行する際、指定されたファイルが存在しない場合に
出力するログの種別を Warn から Debug に変更した。

--

シナリオから TryActiveOne や TryActiveUll を実行する際、たとえ外部コマンドや外部常駐アプリに
生成させるファイルがみつからない場合であっても、エラーとはみなさないように変更した。

--

シナリオや UI から ActiveOne や ActiveUll を実行した際、
端末別に展開されるファイル名が指定されており、各々のファイルが存在しなかった場合において
出力するログの種別を Warn から Error に変更した。

--

外部から MSMQ で受け付ける操作に TryActiveOne と TryActiveUll を追加した。

--

シナリオに下記のステートメントを追加
	CheckBinFile
	CheckCsvFile

--------
2018
--------

以下のシナリオ拡張案を実現する。

	文字列または16進で記述したバイト列を指定したファイル（新規作成／追記）に書き込むステートメントを用意する。
	文字列の一部を端末数に置き換えられるようにする。
	文字列の一部を「i番目の端末の線区や号機番号」に置き換えられるようにする。
	文字列の比較ステートメントを用意する。
	端末[i] の機器構成情報にアクセスできるようにする。（項目ごとに文字列として取得できるようにする）
	文字列の連結ができるようにする。
	文字列型の変数を用意できるようにする。

	外部アプリとの連動の有無によらず、ActiveGetシーケンスやPassivePostシーケンスによって（電文で）取得したデータを
	任意の（ActiveGetステートメントやWaitForPassivePostステートメントなどのパラメータで指定した）ファイルに
	保存できるようにしたい。保存したファイルは、CheckBinFileステートメントなどで活用できるはず。
	また、これによって、電文で受信したデータの正当性を判定するだけの単純なシナリオだけでなく、
	電文で受信したデータを蓄積するような実機模擬用のシナリオを（外部アプリなしで）記述することも可能になるはず。

	上記に伴い、WaitForPassivePostステートメントなどで保存対象電文を絞るにあたり、
	長いPassivePostReq電文の先頭部分だけを比較することになると思われるため、
	あらゆるステートメントの「比較用ファイルパス」「マスク用ファイルパス」の後に「比較バイト数」を記述するよう、
	仕様を変更したい。

	なお、WaitForPassivePostについては、これまでの（外部アプリ連動時の）ようにコンテキスト別に受信電文を保存しないと、
	外部アプリがそれを読み取っている途中で新しいPassiveGetシーケンスが始まって上書きされてしまう可能性がある
	が、WaitForPassivePostの場合は、駅務機器側がデータを返信しないことから明らかなように、
	そもそも外部アプリに処理させる必要がなくなるかもしれない。
	しかし、「$ContextDir<>\〜」のように指定することでコンテキスト別の任意ファイルに保存可能にしておく。
		機器別のディレクトリ直下に保存してもよいなら、蓄積できる方がよいが、どうするか？
		新規作成モードと追記モードを用意するか？
		新規作成後、別のコマンドでマージするか？
		逆に常に追記モードとし、新規作成したい場合は、使ってすぐに捨てるようにしておくか？
		→ 外部アプリに処理させる際の（外部アプリ側の）手間を考え、新規作成とする。

	PassiveGet 関連のステートメントでパラメータに「FromExtCmd:」などを記述した場合に、外部プロセスの判断でNAK返信を行えるようにしたい。
	シナリオが（返信電文のデータ部ではなく）返信電文全体を用意する仕様にすれば自然に実現できるはず。
	そうする場合、PassivePost 関連ステートメントでも応答電文をシナリオから指定することになるため、PassiveOne に一本化する方が自然。
	  そうなると、UI も PassiveOne に一本化したい？
	    → とりあえず UI は PassiveGet と PassivePost に分けておいてよい。（むしろその方が、グリッドに登録するキーがObjCodeだけになるし、利便性はよい？）
	    どちらかのタブ登録されているObjCode（および当該タブのSubCmdCode）に電文が一致していれば、PassiveOneの電文とみなし、
	    <電文比較用BINファイル>などとの比較対象とする。
	  ServerAppToAnyEkimuModel にシナリオを生成させる場合との整合性は？
	  ServerAppToAnyEkimuModel は ActiveGet と ActivePost を区別している？
	    → 区別していないので整合性はありそう。

	PassiveUll などの開始時にも、ACK を返信するのか NAK を返信するのかを電文比較用BINファイルだけで決めるのではなく、外部プロセスに判断させたい。
	つまり、RegPassiveUllProcやRegPassiveDllProcのパラメータに<返信電文BINファイルパス>もしくは<NAK事由（空はACKの意）>を追加し、
	そこに「FromExtCmd:」などを記述できるようにしたい。
	 → <NAK事由（空はACKの意）>を追加するとして、そこに「FromExtCmd:〜」を記述された場合の、外部プロセスの処理結果を受け渡す方法について、
	  現状はコンテキストディレクトリの ExtOutput.dat で受け渡すことになっているが、面倒すぎないか？
	  もともと文字列を記述する場所なのだから、「FromExtCmd:〜」は標準出力で受け取った文字列に置換し、
	  「ExtAppFunc:〜」は ExtAppFuncMessageBody に用意した Public Result As String にセットされた文字列に置換するのが自然では？
	  これまでのように ExtOutput.dat を作る場合は、その絶対パスを標準出力に出力する。
	  より多くの箇所で外部プロセスが介入できるよう、あらゆるパラメータで $ExecCmdFunc<...> というパターンが含まれる場合は、
	  必ず外部コマンドを呼び出して、文字列を得るようにする。
	 → PassiveDllの場合は、受信したファイルを比較に掛けるまでは、シーケンスを特定のハンドラに紐づけることはできない。
	  そのような思想でありながらファイル転送前の電文を受信した時点で外部プロセスを実行してもよいのだろうか？
	  シナリオや外部プロセスにおいて、そのような（ファイル転送前の）タイミングで実行される場合は副作用のあることを行わないよう、
	  シナリオ記述者や外部プロセス設計者が自主規制すればよいか？
	 → 後述するように、受信したファイルの内容はハンドラのキーにしない仕様に変更することで整合させるのがよい。
	  ある面で低機能化するようにも感じられるが、基本言語機能を充実させることで、これまでと同じことも可能になるはず。

	RegPassiveXxxProcToNakやWaitForPassiveXxxToNakは廃止にしてもよいが、NAK返信専用に引数を絞った簡易版という位置づけで残しておく。

	NAKを受信した場合など、通信異常発生時に無条件でシナリオをAbortさせるのはやめる
	（異常系のテストで、意図的に異常な電文を送信してNAKやRSTを受信するシナリオもあり得るため）。
		ただし、ちゃんと動き続けられるのかは怪しい。
		たとえば、他のシーケンスでエラーを認識してDisconnect()を実行し、その中から
		ProcOnActiveFooAnonyErrorが呼び出された場合に、そのActiveFooに紐づいているContextの
		ExecSeqをNothingにしても大丈夫なのかなど。

	現状、ActiveFooステートメントにおいて、軽度NAK受信時の移動先は記述できるが、重度NAK受信時や通信異常時の移動先が記述できないため、
	Abortしないかわりにどう動くべきなのかが不透明。まずは、そこをどうにかしないとならない。
	→ ActiveOne, TryActiveOne, ActiveUll, TryActiveUll のパラメータに「重度NAK受信時の移動先」と「通信異常時の移動先」を追加する。

	PassiveFooを（外部プロセスを巻き込んで）途中まで実行し、完了前に（応答電文の送信などで）
	通信異常を検出した場合も、（外部プロセスがそれまでにやっていたことをロールバックするためにも）
	分岐できた方が良いか？
	それとも、PassiveFooには、そもそも軽度のNAKの場合の分岐先なども指定しないので、次行を続行で構わないのか？
	極端な例では、RegPassiveFooProcしていたことによって新しいコンテキストが生成される場合にも、
	途中で失敗しておきながら、登録したProcの次行を新しいコンテキストで続行してよいのか？
	そもそも応答電文のソケット書込みが成功しても相手に届かない場合もあることを考えると、
	検出したところで実際にやるべきことなどないのでは？
	→ PassiveUll は応答受信で終わるので、失敗を確実に認識できるはず。
	 逆に、PassiveDllなどなら、シーケンスが途中で失敗した場合も（登録したProcがシーケンスに紐づいていたなら）
	 登録されたProcの実行を強行する仕様だとしても、外部アプリは、登録したProcにおいてではなく、
	 転送終了のREQ電文を作成するときに、内部状態を変更する（受信したものを内部にコミットする）ことで
	 対処できるが、PassiveUll だと、転送終了のREQ電文に対しACK電文を受信した際に、内部状態を
	 変更する（ULLの完了をコミットする）のが妥当であり、それは、登録したProcそのものにおいてのみ認識可能なはず。
	 よって、失敗した場合と成功した場合を区別するために、最悪でも、「PassiveUllが途中で失敗した場合は、
	 コンテキストは作成したとしても、Procは開始しない」という仕様でなければならない。
	 そして、作成されたコンテキストで違う処理に分岐できるなら、その方が柔軟でよい。
	 WaitForPassiveUllでなくRegPassiveUllProcの場合は、文法的に分岐はできないようにもみえるが、
	 １回のRegPassiveUllProcで複数の（ケース別の）Procを渡すようにすればよい。

	PassiveUllの追加パラメータ
		・開始応答NAK事由（空の場合はACK返信）
			これはなくても問題はないが、要望があったので追加する。
			※これまでなかった理由は、以下のとおり。
				開始REQの内容によってNoDataなNAKを返信したい場合は、転送データファイルパスに
				存在しないファイルのパスを指定すればよい。NoDataのNAKを返信することになる。
				また、BusyなNAKを返信したい場合は、事前に正常系用のProcをUnregPassiveUllProcして、
				NAK返信用のProcをRegPassiveUllProcToNakしておけばよい。
				Busyであるか否かは電文の内容によらないはずなので、それで十分なはずである。

		・NAK返信後（自ら異常系に入るケースである。NAK書込み成功時やNAK書込み失敗時）の処理
			 NAKを返信したことは自ら知っているはずだから、いらない？
			シナリオ単独で未送信データを管理するとしても、NAK返信が決定した際にローカル変数に
			特定の値をセットしておけば、その後、完了時と同じProcが呼ばれたとしても区別はできる。
			しかし、WaitForPassiveUllにおけるNAK返信時に「待ち続ける」か「次行に進む」か「分岐先に進む」か
			を考えると、「次行に進む」はかなり違和感がある？
			なお、NAK返信時は待ち続ける（何もProcを呼ばない）というのも、ステートメントを実行する
			コンテキストに（または、ステートメントが登録したハンドラに）シーケンスが紐づいている以上、
			不自然すぎる。
			専用の分岐先（処理）を記述できるが、空欄にした場合は「どさくさに紛れて」待ち続ける（処理を呼ばない）
			という「隠し機能」があるのが、高機能でよさそう？
			不自然ではあるが、単純に言ってしまえば、１回のWaitForFooで、いくつものイベントをハンドリングできるイメージ。
			「ハンドラ呼び出しや待機の終了は、何らかのシーケンスがそのステートメントに紐づけば、必ず実施される」
			という方がシンプルではあるが、このケースではシーケンスが電文受信で終わるわけではないし...。
			このようにする場合、現状はかなり割り切っている最大待機期限タイマ関連の実装を、修正する必要がある。
			WaitForPassiveUllでは、それらしきイベントを検出しても、分岐先が確定するまで最大待機期限の
			タイマをキャンセルしないようにしなければならない。
			逆に、コンテキストにシーケンスが紐づいている状態でタイムアウトが発生しても、
			即座にタイムアウトに分岐するのではなく、分岐先が（空欄であることが）確定するまでは
			保留にしなればならない。
			なお、待ち続けると言っても、受信電文を比較した時点で、そのシーケンスはこのステートメントを
			実行するコンテキストに（または、このステートメントが登録したハンドラに）結びついているわけであるから、
			その後で他のコンテキストや他のハンドラに結び付け直して、そちらのパラメータ展開を実行するなどと
			いうことはできないし、やろうとしてはならない。
			これは、WaitForPassiveDllやRegPassiveDllProcにおいて、開始REQ電文受信からFTPでファイルを
			受信する（ステートメントにシーケンスを紐づかせる）までの間に、シーケンス実行時に展開可能な
			パラメータがあってはならないことと似ている。

			→ 仕様的に汚いし、実装も複雑になるので、分岐先を空欄にしたケースでは待ち続けるというのは
			やめた方がよい。高機能と言っても、シナリオ内で現在日時を取得したり、日時の差を算出できるようにすれば、
			同等のことは実現できる（NAK受信の場合は、持ち時間が0以下になっていない限り、待機の開始に戻ればよい）。
			ただし、受動的に（電文受信で）シーケンスが異常終了するケースのことを考えると、
			専用の分岐先は指定できる方が一貫性がある（空欄を禁止にするだけ）。

		・通信異常時（受動的に異常系に入ったケースである。NAK書込み失敗は含まないが、NAK受信に起因するものは含む）の処理
			→ NAK返信後の処理と同じく、専用の分岐先（処理）を指定できるとよい。

		・シーケンス正常終了後の処理（既存のパラメータ）
			あくまでも、シーケンス正常終了後（終了のACK受信後）に限定した処理とする。

	PassiveOneの追加パラメータ
		・応答電文（既存PassiveGetの返信データ相当）

		・NAK返信後の処理？
			ソケットへの書込み失敗時も含む。
			応答電文がACKでもNAKでもない場合は？

		・通信異常時の処理？
			ACK書込み失敗をシーケンス完了とするなら、該当ケース無し

		・シーケンス正常終了後の処理（既存のパラメータ）
			あくまでも、シーケンス正常終了後（ACK返信後）に限定した処理とする。ACK書込み失敗後も含む？

		→ 「応答電文」と「シーケンス終了後の処理」だけでよい。
		PassiveOneでできることは、「サーバから受け取ったデータを保存し、
		保存済みであることをサーバに伝えること」と「サーバからの要求に応じて
		データを返信すること」の２種類だが、クライアント側で（でも）管理できるのは、
		前者におけるDLL済みデータだけである（後者においてどのデータをULL済みかを
		クライアント側で管理するのはNGである）。よって、PassiveUllとは根本的に違う。
		なお、外部プロセスにデータの管理を行わせるなら「シーケンス終了後の処理」も不要であるが、
		これは、シナリオ自身でデータの管理を行うためのものである。
		応答電文としてACKを作成したのかNAKを作成したのかは、作成したファイルの内容を
		「シーケンス終了後の処理」でチェックすれば分かることである（ACKか否かをローカル変数に
		記憶しておいてもよい）。

	PassveDllの追加パラメータ
		・開始応答NAK事由（空の場合はACK返信）とNAK返信時の処理
			これらは追加しない方が無難か？
			(理由) PassiveDllでは、受信するファイルも含めて照合が完了しないと
			シーケンスを捕捉することができないため、開始応答NAK事由は用意できない。
			用意しても、展開対象とするのは変であるし、電文内容のみなら合致する
			（ファイルを照合しないと、優先順位だけでは、どれで捕捉することになるのか
			わからない）PassiveDllProcが複数登録されている場合に、
			どれの開始応答NAK事由を使用するべきなのか判断できないわけである。
			そもそも、NAK返信専用でないPassiveDllのステートメントには開始応答NAK事由は不要である。
			PassiveDllでは、端末側がデータを用意するわけではないため、
			開始REQに対してNoDataのNAKを返信することがあり得ない。
			BusyのNAKは返信し得るが、Busyであるか否かは電文の内容によらないはずなので、
			Busyなときは事前に正常系用のProcをUnregPassiveDllProcして、
			NAK返信用のProcをRegPassiveDllProcToNakしておけばよい。

			→ 受信したファイルは照合の対象外にすればよいし、その方が自然では？
			どの種類のシーケンスであるのかは、開始REQ電文だけみればわかるはずであり、
			Procは（本質的な意味では）シーケンスの種類ごとに登録するべきものだからである。
			捉えたシーケンスのその後の動きを（受信ファイルの内容で）分岐させたい場合は、
			「終了電文情報」を生成する際に（そこに仕込んだ$Foo<>で）制御すればよい。

		・通信異常時の処理
			DLLシーケンスはファイル受信完了した時点で成功扱いであり、その後発生した通信異常は
			受信ファイルの処遇に影響させてはならない。
			つまり、シーケンスの正常終了は、これまでの仕様におけるシーケンス捕捉（ファイル受信完了）
			と同時に発生するわけであり、捕捉したシーケンスにおける通信異常などあり得なかった。
			ファイル受信完了後の通信異常を検出しようにも、現在のTelegrapherの思想では、
			シーケンス内の通信異常として検出するのは困難である（シーケンスと無関係に
			純粋な通信異常として検出することは、当然可能である）。
			ただし、テストを行う上で（？）シーケンス単位で異常とみなしたいという
			ニーズがあるもよう（実際は、他のシーケンスの異常によって回線が切られれば、DLLの
			シーケンスも失敗し得るわけで、シーケンス単位で判定しても特に意味はないはずだが、
			試験項目の体裁上...？）。
			駅務機器を正しく模擬したい場合は、シナリオおよび外部アプリの設計者が
			「シーケンス完了時でなくファイル受信完了時に保存状態を確定するよう配慮する感じに。
			なお、これを実現するためには、ClientTelegrapherから改造して、シーケンスの完了まで
			追いかけられるようにする必要がある。

	WaitForPassiveGetステートメントに保存させたファイルのように（新規作成モードで作成した）一時的なファイルを
	別のファイルにマージする際など、頻繁に使うことが想定されるため、ファイルの連結を行うステートメントを用意する？
	→ ファイルから読み出したバイト列を別のファイルに追記するだけなら、
	 $AppendBytesToFile<$BytesFrFile<Path1>; Path2>
	 でよいので、とりあえず用意しない。もっと高機能なマージが必要なら、必要に応じた仕様から考える。

--
(DONE)

パラメータ内に記述可能なエスケープシーケンス

	$[$]	$
	$[,]	,
	$[>]	>
	$[;]	;
	$[ ]	空白文字(0x20)
	$[HT]	空白文字(水平タブ)
	$[CR]	改行文字(CR)
	$[LF]	改行文字(LF)
	$[NUL]	ヌル文字

	$[Bar] や $Baz<> から返却された文字列の中の特殊な文字は、以下のように置き換えて、
	次の $Baz<> の中で「;」で区切られた要素に分解した後に
	（および最終的な文字列をステートメントに入力する前に）
	元の文字に戻す。
		ヌル文字 → Chr(0) & "0"  ・・・・ 他の特殊な文字を Chr(0) & "$" に置き換えるので、その Chr(0) と区別できるように
		"$" → Chr(0) & "1" ・・・・ 展開結果に含まれる「$[Bar]」や「$Baz<」は、展開対象とはみなさないように
		">" → Chr(0) & "2" ・・・・ 展開結果に含まれる「>」は、他の$Foo<...の閉じ括弧とはみなさないように
		";" → Chr(0) & "3" ・・・・ 展開結果に含まれる「;」は、他の$Foo<...>の中においても、区切り記号とはみなさないように（区切り記号にしたい場合は$ValidateSep<>の中に入れる）
		空白文字(0x20) → Chr(0) & "4"  ・・・・「;」で区切った後のトリムで削られないように
		空白文字(水平タブ) → Chr(0) & "5"   ・・・・「;」で区切った後のトリムで削られないように
	↓
	そもそも、cmd.exe や Processクラスによる引数の解析で「;」は区切りとして解釈されるので、$ExecCmdFunc<...>の中に記述された場合は、
	「;」をエスケープすることに意味がないが、一貫性のため...

--
(DONE)

パラメータ内（や他の関数呼び出し式の引数内）に記述可能な関数呼び出し式

	$ExecCmdFunc<コマンド名; コマンド引数（セミコロン区切り可）; 最大待機時間>
	$ExecAppFunc<送信先メッセージキュー名; メッセージ内容（セミコロン区切り可）; 最大待機時間>

	$MidStr<文字列; 抽出開始位置; 最大抽出文字数>
	$LeftStr<文字列; 最大抽出文字数>
	$RightStr<文字列; 最大抽出文字数>
	$StrElem<文字列; 抽出位置>
	$InStr<文字列; 検索文字列> or <文字列; 検索文字列; 検索開始位置> or <文字列; 検索文字列; 検索開始位置; 最大検索文字数> // みつからない場合は-1
	$InStrRev<文字列; 検索文字列> or <文字列; 検索文字列; 検索開始位置> or <文字列; 検索文字列; 検索開始位置; 最大検索文字数> // みつからない場合は-1
	$StrLen<文字列>
	$Replace<文字列; 置換する部分文字列; 置換後の部分文字列>
	$TrimSp<文字列>  // 空白文字類（空白と水平タブ）を対象とする
	$TrimBr<文字列>  // 改行文字類（CRとLF）を対象とする
	$Trim<文字列>  // 空白文字類と改行文字類を対象とする
	$ToUpper<文字列>
	$ToLower<文字列>
	$Format<複合書式指定文字列; 書式指定項目に渡す数値や日時のセミコロン区切りリスト>  // 戻り値は書式設定された文字列。書式指定項目は{項目番号:D2}のように記述。
	$BytesFrStr<文字列; EncodingID> or <文字列; EncodingID; バイト数> or <文字列; EncodingID; バイト数; 余白バイト16進コード>  // バイト数分のバイト列に入らない場合はエラー
	$StrMin<文字列; 文字列 ...>
	$StrMax<文字列; 文字列 ...>

	$MidBytes<バイト列; 抽出開始位置; 抽出バイト数>  // バイト列はハイフン区切りの16進数。
	$LeftBytes<バイト列; 抽出バイト数>
	$RightBytes<バイト列; 抽出バイト数>
	$BytesElem<バイト列; 抽出位置>
	$InBytes<バイト列; 検索バイト列> or <バイト列; 検索バイト列; 検索開始位置> or <バイト列; 検索バイト列; 検索開始位置; 最大検索バイト数> // みつからない場合は-1
	$BytesLen<バイト列>
	$BitAndOfBytes<バイト列; バイト列>
	$BitOrOfBytes<バイト列; バイト列>
	$BitXorOfBytes<バイト列; バイト列>
	$BitNotOfBytes<バイト列>
	$UIntFrLeBytes<バイト列>
	$UIntFrBeBytes<バイト列>
	$IntFrLeBytes<バイト列>
	$IntFrBeBytes<バイト列>
	$LeBytesFrInt<整数値; バイト数>  // バイト数分のバイト列に入らない場合はエラー
	$BeBytesFrInt<整数値; バイト数>  // バイト数分のバイト列に入らない場合はエラー

	$MidFields<項目列; 抽出開始位置; 抽出項目数>  // 項目列は空白区切りの文字列。"!"は特殊文字。"!"に続く２文字は16進のASCIIコードとみなす。よって、区切りではない空白は"!20"、!記号は"!21"で記述可能。"!"に続く２文字が16進数とみなせない場合はエラー。"!"に続く２文字の16進数がASCIIコードとみなせない場合もエラー。
	$LeftFields<項目列; 抽出項目数>
	$RightFields<項目列; 抽出項目数>
	$FieldsElem<項目列; 抽出位置>
	$InFields<項目列; 検索項目> or <項目列; 検索項目列; 検索開始位置> or <項目列; 検索項目列; 検索開始位置; 最大検索項目数> // みつからない場合は-1
	$FieldsLen<項目列>

	$MidArray<要素; 要素 ...; 抽出開始位置; 抽出要素数>
	$LeftArray<要素; 要素 ...; 抽出要素数>
	$RightArray<要素; 要素 ...; 抽出要素数>
	$ArrayElem<要素; 要素 ...; 抽出位置>
	$InArray<要素; 要素 ...; 検索要素>
	$ArrayLen<要素; 要素 ...>
	$ValidateSep<文字列>  // 区切り文字とみなされないようになっているセミコロンを区切り文字とみなすようにする。

	$Add<数値; 数値>
	$Sub<数値; 数値>
	$Mul<数値; 数値>
	$Div<数値; 数値>
	$Quotient<数値; 数値>
	$Remainder<数値; 数値>
	$Neg<数値>
	$Abs<数値>
	$Int<数値>
	$Ceil<数値>
	$Floor<数値>
	$Min<数値; 数値 ...>
	$Max<数値; 数値 ...>

	$Now<>  // 戻り値は現在日時（出力する日時の形式は yyyy/MM/dd hh:mm:ss.fff）
	$TimeDiff<日時１; 日時２>  // 「日時２ - 日時１」の時間をミリ秒単位の整数値で返却
	$TimeAfter<日時; 時間>  // 時間には「ms」や「s」や「m」や「h」や「d」をつける
	$TimeBefore<日時; 時間>  // 時間には「ms」や「s」や「m」や「h」や「d」をつける

	$StrEq<文字列１; 文字列２>  // 等しければTrue、等しくなければFalse
	$StrNeq<文字列１; 文字列２>  // 等しくなければTrue、等しければFalse
	$StrGeq<文字列１; 文字列２>  // 文字列１ >= 文字列２ ならTrue
	$StrGt<文字列１; 文字列２>  // 文字列１ > 文字列２ ならTrue
	$StrLeq<文字列１; 文字列２>  // 文字列１ <= 文字列２ ならTrue
	$StrLt<文字列１; 文字列２>  // 文字列１ < 文字列２ ならTrue
	$StrCmp<文字列１; 文字列２>  // -1, 0, 1
	$IsZero<数値>  // 0と等しければTrue、0以外の数値ならFalse、数値でなければエラー
	$IsNega<数値>  // 0未満の数値ならTrue、0以上の数値ならFalse、数値でなければエラー
	$IsPosi<数値>  // 0超の数値ならTrue、0以下の数値ならFalse、数値でなければエラー
	$Eq<数値１; 数値２>  // 等しければTrue、等しくなければFalse、数値でなければエラー
	$Neq<数値１; 数値２>  // 等しくなければTrue、等しければFalse、数値でなければエラー
	$Geq<数値１; 数値２>  // 数値１ >= 数値２ ならTrue、数値でなければエラー
	$Gt<数値１; 数値２>  // 数値１ > 数値２ ならTrue、数値でなければエラー
	$Leq<数値１; 数値２>  // 数値１ <= 数値２ ならTrue、数値でなければエラー
	$Lt<数値１; 数値２>  // 数値１ < 数値２ ならTrue、数値でなければエラー
	$And<真偽値; 真偽値 ...>  // 全てがTrueならTrue、１つでもFalseならFalse、TrueやFalseでないものが混ざっていたらエラー
	$Or<真偽値; 真偽値 ...>  // 全てがFalseならFalse、１つでもTrueならTrue、TrueやFalseでないものが混ざっていたらエラー
	$Not<真偽値>
	$If<真偽値; 結果文字列１; 結果文字列２>  // 真偽値がTrueなら結果文字列１、Falseなら結果文字列２、どちらでもなければエラー

	$NewFileOfStr<パス; EncodingID; 文字列>    // パスにテキストファイルを作成する。戻り値はパス
	$NewFileOfBytes<パス; バイト列>    // パスにバイナリファイルを作成する。戻り値はパス
	$AppendStrToFile<文字列; パス; EncodingID>    // パスが示すファイルに文字列を追記する。戻り値は追記した文字列
	$AppendBytesToFile<バイト列; パス>    // パスが示すファイルにバイト列を追記する。戻り値は追記したバイト列

	$StrFrFile<パス; EncodingID>   // 戻り値はファイルから読み出した文字列
	$BytesFrFile<パス>     // 戻り値はファイルから取得したバイト列

	$Val<変数名>    // 戻り値は変数の値（変数の宣言や変数への値の代入は、SetValステートメントで行う）
	$ContextNum<>  // シナリオを実行している駅務機器内の現在のコンテキスト番号
	$ContextDir<>
	$MachineDir<>

--
(中止)

新ステートメント
	SetVal 変数名, 代入する文字列  //変数名も文字列なので$ContextNum<>などを含ませて動的な名前を生成可能

	このステートメントは、宣言と値の代入を兼ねている。
	変数名の先頭が"@"でなければローカル変数。
	ローカル変数は、コンテキスト別に存在するスタックの中のスタックフレームに用意される。
	変数の名前空間はスタックフレームごとに独立している。
	CallステートメントでProcを呼び出すとスタックフレームが用意され、
	そのProcが終了すると、そのスタックフレームが消滅する。
	その際、スタックフレーム内の変数も消滅する。
	//その際、変数がオブジェクトを参照していた場合は、
	//オブジェクトの参照カウンタがデクリメントされ、
	//それが０になれば、オブジェクトはGCの対象となる。
	//⇒DotnetObjな値を廃止したので、これはあり得ないことになった。

	→ 電文を受信したタイミングで（電文の内容をもとに）応答を作成するのに必要な変数を更新したいケースも考えられる。
	つまり、パラメータ展開の中でも変数を更新できないと辛い。
	よって、$SetVal<変数名; 代入する値>を用意し、このステートメントは用意しない。

--
(DONE)

パラメータ内（や他の関数呼び出し式の引数内）に記述可能な関数呼び出し式

	$SetVal<変数名; 代入する値>  // 戻り値は代入した値

	これと同階層の後方に記述された関数呼び出し式や、これの外側にある（典型的にはこれを引数の一部にしている）
	関数呼び出し式では、更新された変数の値を取得できるはず。

--
(DONE)

新ステートメント
	Evaluate 文字列

	文字列を展開するだけのステートメント。
	展開過程で発生する副作用を目的に記述する。
	これを用意するかわりに、CallExtCmdステートメントやCallExtAppステートメントは廃止する。
	SetValステートメントの実装も中止する。

--
(DONE)

Procの定義開始行の書式を下記のように拡張する。

	Proc 処理名(引数を受け取るローカル変数名のカンマ区切りリスト)

--
(DONE)

新ステートメント
	Call 処理名, 引数のカンマ区切りリスト

	RegFooProcで登録して実行させるのと異なり、呼び元のコンテキストでProcを実行することができる。
	ローカル変数の名前空間については、呼び元と別に用意される。
	ローカル変数という概念を活かすには狭い変数スコープを作り出したくなるはずであるが、そのためだけにProcを定義したのであれば、
	このステートメントでProcを実行するのが適切である。

	「処理名」もステートメントのパラメータである（ドル記号部分が展開の対象になる）から、動的に指定可能である。
	よって、実引数と仮引数の件数の整合性チェックなどは、シナリオをロードしたときには行われず、
	このステートメントを実際に実行するときに行われることに注意。
	これは、RegFooProcで登録する処理などにも言える。

	→ シナリオ内にProcだけでなく戻り値つきのFuncも定義可能とし、それを呼び出すステートメントも用意しては？
--
(中止)

新ステートメント
	CallToSetVal 変数名, 関数名, 引数のカンマ区切りリスト  // 変数名も文字列なので$ContextNum<>などを含ませて動的な名前を生成可能

	→ 外部コマンドですらパラメータの展開過程で呼び出すことができるのに、シナリオ内で定義した関数の評価を
	このような構文でしか行えないのはアンバランスであるようにも感じるため、このステートメントはやめる？
	かわりに文字列展開言語においてシナリオに定義された関数を呼び出すための構文「$ExecFunc<関数名; 引数リスト>」を用意し、
	それを SetValステートメントのパラメータにするのはどうか。
	ただ、そうなるとStringExpanderに任意の実行器を渡すためのABI的なものを考える必要があり、めんどう...

--
(DONE)

パラメータ内（や他の関数呼び出し式の引数内）に記述可能な関数呼び出し式

	(案)
	$NewDotnetObj<アセンブリ名; クラス名; 引数リスト>  // .NETアセンブリに実装されたクラスのインスタンスを（リフレクションで）作成する。$SetValの引数にできる。
	$ExecDotnetObjFunc<オブジェクト; メソッド名; 引数リスト>  // $NewDotnetObjで作成したオブジェクトのメソッド（戻り値あり）を（リフレクションで）呼び出す。「オブジェクト」には$NewDotnetObj<...>や$Val<オブジェクトを参照する変数名>を記述）
	$ExecDotnetClassFunc<アセンブリ名; クラス名; 静的メソッド名; 引数リスト>  // これで無理矢理コンストラクタを呼べば$NewDotnetObjのかわりにもなる？
	$ExecFunc<シナリオ内で定義した関数名; 引数リスト>

		$ExecDotnetObjFunc や $ExecDotnetClassFunc だけでなく、
		$ExecDotnetObjGetterとかもないとドットネットフレームワーク標準のオブジェクトはまともに使えないのでは？
		それに、プロパティへの代入などを行うために、専用のステートメントを用意するのか？
		そもそも関数の戻り値にString以外を許容する（Object型にする）となると、各関数の引数もObject型にしなければならない。
		そして、個々の関数の望む個々の引数の実際の型を、関数の仕様として登録しておき、
		それがStringの場合にのみSafeWordへの変換を行うようにしなければならない。
		また、その際、実際の型がString以外の場合は、ToStringするか、確実にエラーとするか、ルールを決めないとならない。
		いろいろ面倒。

		シナリオから実行できる（シナリオ向けに用意するべき）ドットネット関数の形式は限定的（全ての引数がStringで、戻り値もString）にした方が堅牢だし、
		ドットネットフレームワーク標準のオブジェクトを全部使えるようにするよりも、むしろ上記以外の形式のメソッド（上記形式のメソッドを動作させるためのメソッド）も含めて、
		ユーザレベルのVB.NET形式クラスをシナリオ内に記述できる等の方がありがたいのでは？

		一方、シナリオ内にシナリオ独自形式でも関数を定義できるなら、それを呼ぶ際は $ExecFunc<関数名; 引数リスト> ではなく
		ドル記号の後に関数名そのものを記述したくなる。
		組み込み関数と区別をなくす感じになる。
		どうするか？
		→ そもそも、シナリオ内にVB.NET形式で関数を記述できるなら、シナリオ内に独自形式で関数を定義できる必要はないのでは？
		VB.NET形式の方が柔軟であるし読みやすく記述できるし、
		内部からStringExpanderを再帰的に呼ぶということもできないので、安心な上、構文要素の依存関係がすっきりする。
		パラメータの展開でシナリオを実行できてしまうと、構文要素だけでなく、ScenarioEnvとStringExpanderの依存関係が複雑になるし。

		以上のことから、下記に統一する。

	$ExecDynFunc<シナリオ内に定義したVB.NET形式のShared関数の名前またはドットネット標準のShared関数の完全名; 引数リスト>

		内部状態を持たせたいかもしれないので、クラスを定義できた方がよい？（インスタンスの作成はシナリオのステートメントから行う？）
		それとも、Shared Function と同じレベルで Shared な変数くらいは宣言できるようにする？
		（シナリオファイルにおける VbCode と EndVbCode で挟まれた部分の内容が、ダミーなクラスの中に写されるルールで）
		関数名に"->"が入っていたらシナリオ内に定義した関数とみなす。そうでない場合のアセンブリ名はよきにはからって探し出す？

	VbCode と EndVbCode で挟んだ部分はいくつでも記述でき、個別にコンパイル対象とする。
	当該部分ごとにハッシュ値を算出し、シミュレータの起動ディレクトリの下に VbCodeCache\ハッシュ値\枝番 
	ディレクトリを作成し、切り出したソースコードとそれをコンパイルしたアセンブリを管理する。
	当該部分の中は純粋なVB.NETのコードとし、クラスやモジュールから記述する。
	ただし、インクルード指令行も記述でき、前述のキャッシュの中には、
	指令行を展開済みのソースコードを管理する。ハッシュ値も展開結果に基づく値とする。

	(例)
	VbCode MyVbCode
		Class Foo
			Public Shared Function Bar(ByVal arg As String) As String
				Return arg & " is specified!"
			End Function
		End Class
	EndVbCode

	Proc MyProc
		Print $ExecDynFunc<MyVbCode->Foo.Bar; はひふへふぉ>
	EndProc

--
(DONE)

新ステートメント
	FinishContext

	ExitProcステートメントが単に「実行中のProcからリターンする」という意味になったので、別途用意する。
	コンテキストの終了まで一気に行いたい場合は、こちらを使う。

--
(DONE)

名前の解決が大変だが、移動先や実行する処理を指定するパラメータにも、ドル記号入りの文字列
を記述できるようにして、分岐先を動的に指定したい。

--
(DONE)

次の行を意味する組み込みの移動先名「Next」を用意したい。

--
(DONE)

移動先や実行する処理を指定するパラメータにもドル記号入りの文字列を記述できるようにしたことに伴い、
CheckBinFileのようなステートメントを廃止して、$IsMatchBinFiles<...> のような真偽値を返却する関数を用意する。

	これにより、
		Goto $If<$IsMatchBinFiles<...>; Next; MyLabel>
	や
		Call $If<$IsMatchBinFiles<...>; MyProc1; MyProc2>
	のような柔軟なコーディングを行うことができるようになる。

	また、このように、通信インタフェース仕様に依存しない処理をStringExpander側にまとめることで、
	他のシミュレータへの機能の水平展開が行いやすくなる。

ただ、もともとあった CheckBinFileステートメントなどは、引数に「Bytes:ハイフン区切り16進バイト列」を記述できるので捨てがたい。
StringExpanderでも「$IsMatchBinFiles<..., $NewFileOfBytes<$ContextDir<>\temp.dat>, ...>」などと記述できるが、
ファイルを書いて読むので性能的に不利であるし、temp.datができてしまうのも嫌な感じである。

	→ MyUtility に Function GetBytesFromPathString(ByVal sPath As String) As Byte() を用意し、
	sPath が "Bytes:" から始まっている場合は GetBytesFromHyphenatedHexadecimalString を呼ぶように実装しておき、
	MyUtility.IsMatchBin におけるファイル比較でもこれを利用して「Byte:ハイフン区切り16進バイト列」に対応する。
	リトライが必要なケースなどで使うことを考えると微妙に思えるが、内部でリトライは行わない。
	他のプロセスに読み取り排他されている場合にIOExceptionそのもの（その派生クラスではない）をスローするというのは、
	FileStreamのメソッドを直接使う場合と変わらないはず。
	よって「このメソッドによって生じる副作用は一切ない。当該ファイルを他のプロセスが非同期に更新する可能性がある
	ケースでは、IOExceptionをスローする可能性があるので、それをCatchした場合にメソッドの呼び出しそのものをリトライ
	するように実装することを推奨する。他のプロセスが排他状態を解いた後のリトライで実行が完了するはずである」
	ということにしておく。

	$IsMatchBinFiles<評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス> or <評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス; 評価バイト数>
	$IsMatchCsvFiles<評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス> or <評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス; 評価項目数>

--
(DONE)

読込み対象のCSVファイルのパスを渡すパラメータや引数には「Fields:空白区切り文字列」を渡すことができるようにする。
詳細仕様は下記のとおり。
	空白区切り文字列において「!」は特殊文字です。
	「!」に続く２文字は16進のASCIIコードとみなします。
	よって、区切りではない空白は「!20」、!記号は「!21」で記述することができます。
	「!」に続く２文字が16進数とみなせない場合はエラーとします。
	「!」に続く２文字の16進数がASCIIコードとみなせない場合もエラーとします。
	「Fields:」の後の文字数が０なら、１つの項目（内容は""）があるとみなします。

--
(DONE)

細かな仕様変更

	RegFooProc で登録した処理の検出順序のルールを変更。
	これまでは登録番号の大きいものが優先的に検出されるようにしていたが、
	登録番号が小さいものが優先的に検出されるようにした。

	比較に用いるファイルを読めない場合などは、比較結果を「不一致」とみなすのではなく、
	シナリオを異常終了させることにした。

	INIのDeleteScenarioTelegFileEachTimeを廃止した。

--
(DONE)

リファレンス型の変数を使いたい。
少なくともProcの引数は参照渡しもできるようにしたい。

（案１）専用の関数でリファレンスを作ったり、間接参照を行ったりする。

		$SetValByRef<リファレンス変数名; 文字列>  // リファレンス変数の参照先変数に代入を行う
		$ValByRef<リファレンス変数名>  // リファレンス変数の参照先変数から値を取得する

		$SetRef<リファレンス変数名; 変数名>  // リファレンス変数を用意する。方式A（リファレンス変数にできることを値変数にできることとを明確に区別する仕様）
		$SetVal<リファレンス変数名; $Ref<変数名>>  // リファレンス変数を用意する。方式B（リファレンス変数同士のコピーを容認する仕様）

	値型変数名の代わりにリファレンス変数名を引数にとる関数が登場する。
	これらの引数はリファレンスであることが明確なため、
	値型変数とリファレンス変数の名前空間は別にすることも可能である。
	ただし、リファレンスのリファレンス（$Ref<リファレンス変数名> または
	$SetRef<リファレンス変数名; リファレンス変数名>）を容認したいなら、
	同一にするのが妥当か？
	名前空間を同一にすると、$ValByRef<別のリファレンス変数へのリファレンス変数名>
	が文字列に代入されたり、文字列と連結されたりする可能性を考慮する必要がある（エラーを発生させる道筋を考えなければならない）。
	また、方式Bで、$SetVal<リファレンス変数名; $Val<リファレンス変数名>> による
	リファレンスのコピーが可能になってしまい、スタックの上段にある変数の参照を
	下段にあるリファレンスにセットできてしまう...
	そもそも、もしグローバルなリファレンス変数も容認するなら、似たような事態は避けようがないが。

	そのような事態を容認するなら、単純に.NETのリファレンス機構で実現するわけにはいかなくなる（拘束するべきでないオブジェクトを拘束してしまうため）。
	仮想変数環境内の位置情報（コンテキスト番号、スタックフレーム番号、変数名 など）で参照先を管理し、
	存在しなくなったものを間接参照しようとしたらエラーを発生させるのが妥当か。
	しかし、それだと、StringExpander に対し、oLocalVariables ではなく、もっと複雑な仮想変数環境一式を渡す必要が生じる。
	それに、コンテキスト0にて、Main から Sub1 を呼び出して、そこ（スタックフレーム番号1）に用意したローカル変数 a の
	リファレンスをグローバル変数 g にセットした後、Main に戻り、Main から再度 Sub1 を呼び出し、
	そこ（スタックフレーム番号1）に再度ローカル変数 a を用意した状況において、g を参照しようとしたら、
	エラーが発生してほしいわけであるが、上記ではそうはならないはず。
	以上のことから、.NETのリファレンス機構を使うことにして、スタックフレームを破棄する際に、
	中の変数を参照している全てのリファレンス変数の値を Nothing にするのがよさそう。
	変数には、値の他に、参照元リファレンス変数へのリンクドリストの起点を持たせておくと、効率的か。

	当然ながら、方式Bやグローバルなリファレンス変数の容認をやめて、
	リファレンス変数よりも先に参照先が消えるなどという可能性を無くしてもよい。

（案２）変数名によりリファレンス（他の変数の別名）であるとみなす。

	たとえばリファレンス変数名の１文字目は"*"にするなど。
	ある意味で値型変数とは名前空間が別になる。
	本質的には案１の方式Aと変わらない？

	・グローバルなリファレンス変数は自然に禁止できる（"*@AAA"はグローバル変数ではない）。
	・参照先変数の値の取得が普通に $Val<リファレンス変数名> で行えるので、ちょっとうれしい。
	・$SetVal<リファレンス変数名; 文字列> は、参照先変数への代入とする。
	・宣言は $SetRef<リファレンス変数名の２文字目以降; 変数名> でいい感じに。
	・リファレンスのコピーは、Proc Foo(*bar1) が存在するとして、Call Foo *var1 を行うケースのみ発生。
		※仮引数がリファレンス型の場合は、実引数には何らかの変数名を記述するルールとする。その場合、
		実引数に値型変数名が記述されているなら、仮引数には実引数のリファレンスをセットする。
		実引数にリファレンス型変数名記述されているなら、仮引数は実引数のコピーとなる。
	・リファレンス変数よりも先に参照先が消えるなどという可能性は、文法的にあり得ない。

→ とりあえず案２の仕様で実装する。
変数値のDictionaryをどうするか。

（実装案A）
	Class VarHolder
		Public Value As Object  'リファレンス型変数なら他のVarHolder、値型変数ならStringを指す。
	End Class

	Dictionary(Of String, VarHolder)

	→ 値型変数１つにつきオブジェクトを２つ用意するのは勿体ない。
	作成する際のヒープからのメモリ取得回数が２回になるし、
	値を取得する際の間接参照回数が２回になる。
	ただし、リファレンスの参照は速い。

（実装案B）
	Class VarAddr
		Public Container As Dictionary(Of String, Object)
		Public Name As String  'Containerにおけるキー名
	End Class

	Dictionary(Of String, Object)  'リファレンス型変数のValueはVarAddr型、値型変数のValueはString型

	→ 値型変数１つにつきオブジェクトは１つ用意するだけ。
	ただし、リファレンス変数の参照先にアクセスする際にDictionary.GetValueを２回行う必要がある。
	リファレンス変数の作成は、実装案Aよりも速い（実装案Aでは、参照先変数のVarHolderをDictionaryから
	探す必要があるのに対し、この案ではそれが必要ない）ようにも思えるが、そのようなことはない
	（この案でも、$SetRef<A;B> におけるBが現在スコープされている辞書に存在していない場合は
	その場でエラーを発生させたいため、同じことは必須である）。

実装案Aで実装する。
実装案Aの方が単純であるし、仮に「グローバルなリファレンス変数を容認し、
参照先の変更などを行うまで、参照先ローカル変数を拘束し続ける」などの仕様に
した場合に、実際に拘束するオブジェクトのサイズが圧倒的に小さくて済む。

--
(DONE)

実装メモ
//GetExtOutputPathを廃止する。
//GetExtOutputPathの戻り値のかわりに StringExpander.Expandの戻り値を使う。
//StringExpander.Expandの呼び出しは Try の中に入れる。
//StringExpander.Expandの戻り値の長さが0の場合に対応する。
//ExtAppFuncMessageBody に  Public Result As String を用意し、各アプリを対応させる。
//oParentMessageQueue は MyTelegrapher が管理し、ScenarioEnv のコンストラクタに参照を渡す。
//IsMatchBin（IsMatchCsv）の中でファイルが無かったり外部プロセス関係のエラーが発生した場合は例外を漏らすようにする。呼び元でCatchしてAbortScenarioする。
//StringExpander.Expandにおいて、引数の誤りで例外が発生し得るケースでは、それをCatchして、Messageプロパティが"$Foo requires <...>"のFormatExceptionで包む。

--
(2018年シナリオ拡張の重要事項まとめ)

シナリオから外部コマンドを実行した際は、その標準出力を処理結果として受け取れるようにした。
シナリオから外部アプリに要求を行った際は、その結果（任意の文字列）を応答メッセージから受け取れるようにした。
以上の改善に伴い、ExOpmgDummyFooBarにおいて、これまでコンテキストディレクトリにExtOuput.datという
固定名のファイルを作っていたケースでは、任意名のファイルを作り、そのパスを結果にセットするようにした。
ただし、DllResultInfo（ファイルDLL終了時のREQ電文のもととする情報）を作成していたケースでは、
ファイルを作成するのではなく、DllResultInfoとする文字列そのものを結果にセットするようにした。

特定のパラメータに記述できた「FromExtCmd:コマンド名;コマンド引数リスト:最大待機時間」は廃止した。
かわりに $ExecCmdFunc<コマンド名;コマンド引数リスト:最大待機時間> を記述することで同等のことを可能とした。
特定のパラメータに記述できた「FromExtAppFunc:メッセージ送信先;メッセージ要素リスト;最大待機時間」は廃止した。
かわりに $ExecAppFunc<メッセージ送信先;メッセージ要素リスト;最大待機時間> を記述することで同等のことを可能とした。
※これらは関数の一種であり、これらが記述された部分は、コマンドやアプリの処理結果に置き換わります。
これらは、全てのパラメータの任意の位置や、他の関数呼び出しの任意の引数の任意の位置に、
何度でも記述することができます。

$ExecCmdFunc<...> や $ExecAppFunc<...> の他にも、多くの関数を用意した。
それに伴い、%ContextDir や %MachineDir は廃止し、
かわりに $ContextDir<> や $MachineDir<> を任意のパラメータ内や任意の引数内に記述できるようにした。

CallExtCmdステートメントは廃止した。
※新たに用意したEvaluateステートメントと$ExecCmdFunc<...>を下記のように組み合わせることで、
同等のことを実現可能です。
           000-000-0000-00 Evaluate $ExecCmdFunc<...>

CallExtAppFuncステートメントは廃止した。
※新たに用意したEvaluateステートメントと$ExecAppFunc<...>を下記のように組み合わせることで、
同等のことを実現可能です。
           000-000-0000-00 Evaluate $ExecAppFunc<...>

外部アプリとの連動の有無によらず、ActiveGetシーケンスやPassivePostシーケンスによって（電文で）
取得したデータを任意の（ActiveGetステートメントやWaitForPassivePostステートメントなどの
パラメータで指定した）ファイルに保存できるようにした。
※保存したファイルは、CheckBinFileステートメントなどで活用できます。
また、これによって、電文で受信したデータの正当性を判定するだけの単純なシナリオだけでなく、
電文で受信したデータを蓄積するような実機模擬用のシナリオを（外部アプリなしで）記述する
ことも可能になります。

上記に伴い、WaitForPassivePostステートメントなどで保存対象電文を絞るにあたり、
長いPassivePostReq電文の先頭部分だけを比較することになると思われるため、
あらゆるステートメントの「比較用ファイルパス」「マスク用ファイルパス」の後に
「比較バイト数」を記述するよう、仕様を変更した。

PassivePostシーケンスとPassiveGetシーケンスは、シナリオ内ではPassiveOneシーケンスとみなし、
単一の方法で扱うようにした。

ULL系やDLL系のステートメントにおける「ファイル転送期限」の記述位置は
「転送ファイルハッシュ値」の直後に変更した。

時間を「分」で記述する場合の接尾語を「min」から「m」に変更した。

PassiveFooシーケンスにおいて、受信したデータの内容からだけでなく、駅務機器の状態に
応じてNAKを返信できるように、各種ステートメントの仕様および書式を変更した。
それに伴い、PassiveDllシーケンスをシナリオで捕捉するためのキーから「受信ファイルの内容」は除外した。

シナリオから実行した能動的シーケンスや、シナリオで捕捉した受動的シーケンスの実行中に
通信エラーが発生した場合も、シナリオの実行を中止させず、シナリオ内で分岐できるよう、
各種ステートメントの仕様および書式を変更した。

Procをサブルーチンのように呼び出せるようにした。
また、呼び出されるProcは引数を受け取れるようにした。

変数という概念を用意した。

VB.NETのソースコードやC#のソースコードをシナリオ内に記述し、
Procのステートメントから呼び出せるようにした。

RegFooProc で登録したハンドラの検出順序のルールを変更した。
これまでは登録番号の大きいものが優先的に検出されるようにしていたが、
登録番号が小さいものが優先的に検出されるようにした。

比較に用いるファイルを読めない場合などは、比較結果を「不一致」とみなすのではなく、
シナリオを異常終了させることにした。

INIファイルのDeleteScenarioTelegFileEachTimeという項目を廃止した。
