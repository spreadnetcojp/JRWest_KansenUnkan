
◆シナリオファイルの書式

多重駅務機器シミュレータは複数の駅務機器を内蔵していると考えてください。
シナリオの開始や停止の操作は、駅務機器ごとに独立して行うことができます。
「シナリオ」タブの実行ボタンが押下されると、画面左のグリッドで選択されている全ての駅務機器は、
指定されたシナリオファイルの中の「Main」という名前の処理を、各々で実行します。
シナリオファイルの各行の書式は以下のいずれかになります。(1)の書式の行と(2)の書式の行の間に
(3)以降の書式の行だけがある場合、それらの行を１つの処理とみなします。
基本的に、処理の各行は、上から順に実行されます。

(1)処理の定義開始行（２種類）
   Proc 処理名
   Proc 処理名(仮引数のカンマ区切りリスト)
(2)処理の定義終了行
   EndProc

(3)TCPレベルの接続を行うための行
   実行機器 Connect 接続済みの場合の移動先, 接続失敗時の移動先
(4)TCPレベルの切断を行うための行
   実行機器 Disconnect
(7)能動的単発シーケンスを行うための行（２種類）
   実行機器 ActiveOne 送信電文BINファイルパス, 受信電文保存先BINファイルパス, 応答電文待ち時間, 軽度NAKが返ってきた場合の移動先, 重度NAKが返ってきた場合の移動先, 通信異常でシーケンス終了した場合の移動先, シーケンス成功時の送信電文ファイル削除要否
   実行機器 TryActiveOne 送信電文BINファイルパス, 受信電文保存先BINファイルパス, 応答電文待ち時間, 軽度NAKが返ってきた場合の移動先, 重度NAKが返ってきた場合の移動先, 通信異常でシーケンス終了した場合の移動先, シーケンス成功時の送信電文ファイル削除要否
(8)能動的ULLシーケンスを行うための行（２種類）
   実行機器 ActiveUll データ種別, 電文内ファイル名, 転送データファイルパス, 転送データファイルハッシュ値, 転送待ち時間, 開始応答電文待ち時間, 終了応答電文待ち時間, 軽度NAKが返ってきた場合の移動先, 重度NAKが返ってきた場合の移動先, 通信異常でシーケンス終了した場合の移動先, シーケンス成功時の転送データファイル削除要否
   実行機器 TryActiveUll データ種別, 電文内ファイル名, 転送データファイルパス, 転送データファイルハッシュ値, 転送待ち時間, 開始応答電文待ち時間, 終了応答電文待ち時間, 軽度NAKが返ってきた場合の移動先, 重度NAKが返ってきた場合の移動先, 通信異常でシーケンス終了した場合の移動先, シーケンス成功時の転送データファイル削除要否
(9)受動的単発シーケンスを待つための行
   実行機器 WaitForPassiveOne 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 受信電文保存先BINファイルパス, 返信電文BINファイルパス, 検出待ち時間, 検出待ち時間が経過した場合の移動先
(10)NAK返信を前提に受動的単発シーケンスを待つための行
   実行機器 WaitForPassiveOneToNak 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 受信電文保存先BINファイルパス, NAK事由, 検出待ち時間, 検出待ち時間が経過した場合の移動先
(11)受動的ULLシーケンスを待つための行
   実行機器 WaitForPassiveUll 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, 転送データファイルパス, 転送データファイルハッシュ値, 転送待ち時間, 終了応答電文待ち時間, 検出待ち時間, 開始NAK返信でシーケンス終了した場合の移動先, 通信異常でシーケンス終了した場合の移動先, 検出待ち時間が経過した場合の移動先
(12)NAK返信を前提に受動的ULLシーケンスを待つための行
   実行機器 WaitForPassiveUllToNak 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, 検出待ち時間, 検出待ち時間が経過した場合の移動先
(13)受動的DLLシーケンスを待つための行
   実行機器 WaitForPassiveDll 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, 比較バイト数, 終了電文情報, 終了応答電文待ち時間, 検出待ち時間, 開始NAK返信でシーケンス終了した場合の移動先, 通信異常でシーケンス終了した場合の移動先, 検出待ち時間が経過した場合の移動先
(14)NAK返信を前提に受動的DLLシーケンスを待つための行
   実行機器 WaitForPassiveDllToNak 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, 検出待ち時間, 検出待ち時間が経過した場合の移動先
(15)指定時間の経過を待つための行
   実行機器 Wait 時間
(16)指定日時まで待つための行
   実行機器 WaitUntil 日時

(25)GET電文受信シーケンスの登録を行うための行
   実行機器 RegPassiveOneProc PassiveOne登録番号, 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 受信電文保存先BINファイルパス, 返信電文BINファイルパス, シーケンス終了後に実行する処理
(26)NAK返信を前提にしたGET電文受信シーケンスの登録を行うための行
   実行機器 RegPassiveOneProcToNak PassiveOne登録番号, 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 受信電文保存先BINファイルパス, NAK事由, シーケンス終了後に実行する処理
(27)GET電文受信シーケンスの登録解除を行うための行
   実行機器 UnregPassiveOneProc PassiveOne登録番号
(28)受動的ULLシーケンスの登録を行うための行
   実行機器 RegPassiveUllProc PassiveUll登録番号, 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, 転送データファイルパス, 転送データファイルハッシュ値, 転送待ち時間, 終了応答電文待ち時間, 開始NAK返信でシーケンス終了した場合に実行する処理, 通信異常でシーケンス終了した場合に実行する処理, シーケンス正常終了後に実行する処理
(29)NAK返信を前提にした受動的ULLシーケンスの登録を行うための行
   実行機器 RegPassiveUllProcToNak PassiveUll登録番号, 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, NAK返信後に実行する処理
(30)受動的ULLシーケンスの登録解除を行うための行
   実行機器 UnregPassiveUllProc PassiveUll登録番号
(31)受動的DLLシーケンスの登録を行うための行
   実行機器 RegPassiveDllProc PassiveDll登録番号, 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, 終了電文情報, 終了応答電文待ち時間, 開始NAK返信でシーケンス終了した場合に実行する処理, 通信異常でシーケンス終了した場合に実行する処理, シーケンス正常終了後に実行する処理
(32)NAK返信を前提にした受動的DLLシーケンスの登録を行うための行
   実行機器 RegPassiveDllProcToNak PassiveDll登録番号, 電文比較用BINファイルパス, 電文マスク用BINファイルパス, 比較バイト数, 開始応答NAK事由, NAK返信後に実行する処理
(33)受動的DLLシーケンスの登録解除を行うための行
   実行機器 UnregPassiveDllProc PassiveDll登録番号
(34)切断検出時の処理を登録するための行
   実行機器 RegDisconnectProc DisconnectProc登録番号, 実行する処理
(35)切断検出時の処理を登録解除するための行
   実行機器 UnregDisconnectProc DisconnectProc登録番号
(36)処理の繰り返しを登録する行
   実行機器 RegTimerProc Timer登録番号, 回数, インターバル, 実行する処理
(37)処理の繰り返しを登録解除する行
   実行機器 UnregTimerProc Timer登録番号

(40)BINファイルを比較する行
   実行機器 CheckBinFile 対象BINファイルパス, 比較用BINファイルパス, マスク用BINファイルパス, 比較バイト数, 不一致の場合の移動先
(41)CSVファイルを比較する行
   実行機器 CheckCsvFile 対象CSVファイルパス, 比較用CSVファイルパス, マスク用CSVファイルパス, 比較項目数, 不一致の場合の移動先

(50)パラメータの展開のみを行う行
   実行機器 Evaluate 展開させる文字列
(51)ログ出力を実施する行
   実行機器 Print 出力する文字列
(60)次に実行する行を指定するための行
   実行機器 GoTo 移動先
(61)移動先の目印行
   #ラベル
(62)別の処理を呼び出すための行
   実行機器 Call 処理名, 処理に渡す引数のカンマ区切りリスト
(63)現在の処理を終了させるための行
   実行機器 ExitProc
(64)現在の文脈を終了させるための行
   実行機器 FinishContext
(65)シナリオの実行を結果OKで終了させるための行
   実行機器 FinishScenario
(66)シナリオの実行を結果NGで終了させるための行
   実行機器 AbortScenario

(80)VB.NETコードの定義開始行
   VbCode コードブロック名
(81)VB.NETコードの定義終了行
   EndVbCode

(90)C#コードの定義開始行
   CsCode コードブロック名
(91)C#コードの定義終了行
   EndCsCode

※ シミュレータ内蔵の各駅務機器は、「実行機器」部分が自分自身の機器コードとマッチしない行を実行しません。
   「実行機器」部分の書式は「線区コード-駅順コード-コーナーコード-号機番号」です。
   「-」で区切られる各コードおよび号機番号は、半角数字で記述してください。ゼロ埋めで記述しても、ゼロサプレスして記述しても構いません。
   「0」を記述した場合、その部分はワイルドカードとみなされ、あらゆるコードまたは番号とマッチします。
※ 「時間」や「〜待ち時間」や「インターバル」には「数d」「数h」「数m」「数s」「数ms」のいずれかを記述可能です。
   「数」は任意桁数の半角数字列ですが、小数点も記述できます。
※ 「日時」には「YYYY/Month/Day hour:minute:sec」または「hour:minute:sec」
   または「+Days hour:minute:sec」または「+hour:minute:sec」
   または「++Days hour:minute:sec」または「++hour:minute:sec」のいずれかを記述可能です。
   YYYYは4桁の半角数字で記述しなければなりませんが、Month、Day、hour、minute、secは、
   月、日、時、分、秒とみなせる範囲であれば、桁数は問いません（ゼロ埋めしてもしなくても構いません）。
   secについては、小数点以下も3桁まで記述可能です。
   Daysは、正の整数とみなすことができれば、オーバーフローしない範囲で任意の数字を記述可能です。
   「hour:minute:sec」の書式は、待機開始以降に訪れる最初の「hour時minute分sec秒」を表します。
   ただし、待機開始時点のシステム時刻が「hour時minute分sec秒から0秒〜1分が経過した時点の時刻」とみなせる場合は、
   既に指定の時刻になっているものとみなし、停止を行いません（よって、この書式の場合の最大の停止時間は23時間59分になります）。
   「+」で始まる書式は、「現在の文脈の生成時点から指定の時間が経過した時点」とみなされます。
   「++」で始まる書式は、「最初の文脈（Main文脈）の生成時点から指定の時間が経過した時点」とみなされます。
    たとえば「+3 1:2:30.5」は、現在の文脈の生成時点から3日と1時間2分30.5秒が経過した時点とみなされます。
※ 「データ種別」には、プロトコル仕様に従い、2桁の16進数を記述してください。
※ 「〜ファイルハッシュ値」の正しい書式は32文字の16進ASCII文字列です。
   また、これはブランクにすることも可能です。その場合は、ファイル内容からハッシュ値を計算します。
※ 「〜NAK事由」には、NAK事由コード（3文字の半角数字）とそれに続くNAK事由文言（最大47文字の可読ASCII文字）を記述してください。
   ただし、(11),(13),(28),(31)で、捉えたシーケンスの開始REQ電文に対しACK電文を返信させたい場合は、ブランクにしてください。
※ (13)や(31)の「終了電文情報」の書式は、「終了コード; 保持バージョン１; 保持バージョン２; 受信可能フラグ」です。
   終了コードは、「Finish」「FinishWithoutStoring」「Abort」のいずれかを記述してください。
   保持バージョン１と保持バージョン２には、それぞれ0〜99999999の数値を半角数字で記述してください。
   受信可能フラグには、0〜255の数値を半角数字で記述してください。
※ 「移動先」や「〜時の移動先」には、同じProc内で定義しているラベルを記述してください。
   ただし、「Next」というラベルは組み込みで定義されている特殊なラベルであり、常に使用可能です。これは現在行の次行を表します。
※ 「〜ファイルパス」には、絶対パスまたはシナリオファイルを格納しているフォルダからの相対パスを記述してください。
※ 保存先の「〜ファイルパス」はブランクとすることが可能です。その場合、保存を行いません。
※ (7)の書式の行の「送信電文BINファイルパス」に記述したパスのファイル名に「?」や「*」が含まれる場合、当該部分はワイルドカードとみなされます。
   その場合、当該行を実行する際、ディレクトリの検索が行われ、マッチしたファイルごとに、シーケンスが実行されます。
※ (8)の書式の行の「転送データファイルパス」に記述したパスのファイル名に「?」や「*」が含まれる場合、当該部分はワイルドカードとみなされます。
   その場合、当該行を実行する際、ディレクトリの検索が行われ、マッチしたファイルごとに、シーケンスが実行されます。
※ 保存先でない「〜BINファイルパス」には、「Bytes:」に続けて、「-」区切りのバイト列を16進数で記述することも可能です。
   その場合、当該バイト列が格納されたファイルを仮想して処理が行われます。
※ 電文比較用BINファイルは、特定種別（= GUIの受動的XXXタブに登録されている種別）のREQ電文を受信した際に、それと比較するためのファイルです。
   電文マスク用BINファイルは、比較の前に、受信電文と電文比較用BINファイルに対しマスクを行うための（ビットANDする）ファイルです。
   「電文比較用BINファイルパス」に「*」を記述し、「比較バイト数」に任意の正数（バイト数）を記述すると、受信電文のサイズが任意のバイト数以上である場合に比較結果が一致になります。
   「電文比較用BINファイルパス」に「*」を記述し、「比較バイト数」に0以下の数を記述すると、比較結果は常に一致になります。
   「電文比較用BINファイルパス」をブランクにすると、比較結果は常に不一致になります。
   受信電文の内容を比較する場合は、「電文比較用BINファイルパス」に実在するファイルのパスを記述してください。
   以下、電文比較用BINファイルパス」に実在するファイルのパスを記述した場合についての動作を説明します。
     「比較バイト数」を0とした場合、比較結果は常に一致となります。
     「比較バイト数」が正数の場合は、「比較バイト数」分だけが比較の対象になります。
       その場合、電文比較用BINファイルや電文マスク用BINファイルの長さが「比較バイト数」未満なら、足りない分は0x00が埋められているものとして処理が行われます。
       また、受信電文の長さが「比較バイト数」未満なら、比較結果は不一致となります。
       また、受信電文の長さが「比較バイト数」以上なら、受信電文の長さと電文比較用BINファイルの長さが異なっても、比較結果が不一致になるとは限りません。
       また、「電文マスク用BINファイルパス」に「*」を記述すると、受信電文の長さと「比較バイト数」のみが比較され、受信電文が「比較バイト数」よりも短い場合が不一致となります。
     「比較バイト数」が負数の場合は、電文比較用BINファイル全体が比較に用いられることになります。
       その場合、電文マスク用BINファイルが電文比較用BINファイルより短ければ、足りない分は0x00が埋められているものとして処理が行われます。
       また、受信電文と電文比較用BINファイルの長さが不一致なら、たとえ短い側のバイト数分の内容が完全一致していても、比較結果は不一致となります。
       また、「電文マスク用BINファイルパス」に「*」を記述すると、受信電文と電文比較用BINファイルの長さのみが比較されます。長さが一致しなければ、比較結果は不一致となります。
※ 記述されたパスからファイルを読出すことができない場合など、シナリオに記述された送信用データが用意できない場合、シナリオの実行は結果NGで終了します。
   ただし、TryActiveOneの「送信電文BINファイルパス」やTryActiveUllの「転送データファイルパス」に記述されてるファイルについては、それが存在しない場合も、
   シナリオの実行を継続します（その場合、当該行のシーケンスを実行せず、次の行の実行に移行します）。
   このことからわかるように、TryActiveOneやTryActiveUllは、外部プロセスに不特定数の所定名称ファイルを作成させて、実際に作成されたものだけを
   送信したい場合などにおいて有用です。たとえば、任意のPassveDllが行われた後、それに依存する件数のDL完了通知電文ファイルを外部プロセスに
   作成させて、その全てを送信したい場合が該当します。

※ (7)の書式の行は、ソケットに電文を書き込んだ後、応答とみなせる電文を受信するか通信異常（応答受信タイムアウトなども含む）を検出するまで、待機を行います。
※ (8)の書式の行は、ソケットにシーケンスを開始するための電文を書き込んだ後、何らかのかたちで（たとえばリトライオーバーや通信異常によって）シーケンスが終了するまで、待機を行います。
※ (9),(10),(12),(14)の書式の行は、待機を行うための行です。待機中は、当該のシーケンスの（= 当該シーケンスのタブのデータグリッドに登録されている種別の）
   正しいREQ電文を受信した際に比較を行い、比較結果が一致の場合に、シナリオが示す応答を返信して、次の行に進みます。
   比較結果が不一致の場合は、受信電文に対する応答返信はデフォルトの方法で処理し、当該行における待機を継続します。
   --------------------------------------------------------------------------------
    これらの行で応答の返信を行った際、次の行に進むケースでは、運管サーバ側がその応答を必ず処理する...
    という保証はありません。
    これは、これらのシーケンスの特性です。
   --------------------------------------------------------------------------------
※ (11)の書式の行も、待機を行うための行です。待機中は、受動的ULLシーケンスの（= 「受動的ULL」タブのデータグリッドに登録されている種別の）
   正しいREQ電文を受信した際に比較が行われます。
   比較結果が不一致の場合は、受信電文に対する応答返信やそれに続くシーケンスをデフォルトの方法で処理し、当該行における待機を
   継続しますが、一致の場合は、下記を行います。
   ・「開始応答NAK事由」が示す開始NAK電文または開始ACK電文の送信を行います。
   ・開始NAK電文を送信した場合、「開始NAK返信でシーケンス終了した場合の移動先」に進みます。
   ・開始ACK電文を送信した場合、「転送データファイルパス」が示すファイルのFTPによる送信を開始し、その結果により下記のいずれかを行います。
     ・FTPによるファイル送信が完了した場合は、終了コードが「Finish」の終了REQ電文を送信し、それに対するACK電文を受信した時点で、
       次の行に進みます。
     ・FTPによるファイル送信がタイムアウトした場合は、終了コードが「Abort」の終了REQ電文を送信し、それに対する応答電文を受信した時点
       または応答電文の受信までに通信異常が発生した時点で「通信異常でシーケンス終了した場合の移動先」に進みます。
   ・開始ACK電文の送信で通信異常が発生した場合や、ファイル送信完了後に通信異常が発生した場合は、その時点で
     「通信異常でシーケンス終了した場合の移動先」に進みます。
   --------------------------------------------------------------------------------
    WaitForPassiveUllの「開始応答NAK事由」〜「検出待ち時間が経過した場合の移動先」のいずれかにドル記号が含まれている場合、
    その行に捕捉されたシーケンスの開始REQ電文は"$MachineDir<>\#PassiveUllReq.dat"で示されるファイルに書き出されます。
    このファイルは、そのシーケンスを実行中（すなわち、別の行に進むまでの間）のみアクセスできることに注意してください。
    シーケンスの実行が終了すれば、同名ファイルを新規作成する新たな受動的ULLシーケンスが開始する可能性があるためです。
    厳密には、別の行に進んだ後も、待機を行い得る行を実行するまでは、新たな受動的ULLシーケンスが開始する可能性はありませんが、
    その特性を積極的に活用する局面はあまり多くはないはずです。
   --------------------------------------------------------------------------------
※ (13)の書式の行も、待機を行うための行です。待機中は、受動的DLLシーケンスの（= 「受動的DLL」タブのデータグリッドに登録されている種別の）
   正しいREQ電文を受信した際に比較が行われます。
   比較結果が不一致の場合は、受信電文に対する応答返信やそれに続くシーケンスをデフォルトの方法で処理し、当該行における待機を
   継続しますが、一致の場合は、下記を行います。
   ・「開始応答NAK事由」が示す開始NAK電文または開始ACK電文の送信を行います。
   ・開始NAK電文を送信した場合、「開始NAK返信でシーケンス終了した場合の移動先」に進みます。
   ・開始ACK電文を送信した場合、FTPによるファイル受信を開始し、その結果により下記のいずれかを行います。
     ・FTPによるファイル受信が完了した場合は、「終了電文情報」が示す終了REQ電文を送信し、それに対するACK電文を受信した時点で、
       次の行に進みます。
     ・FTPによるファイル受信がタイムアウトした場合や、受信したファイルにハッシュ値異常を検出した場合は、終了コードが
       「Abort」の終了REQ電文を送信し、それに対する応答電文を受信した時点または応答電文の受信までに通信異常が発生した時点で
       「通信異常でシーケンス終了した場合の移動先」に進みます。
   ・開始ACK電文の送信で通信異常が発生した場合や、ファイル受信完了後に通信異常が発生した場合は、その時点で
     「通信異常でシーケンス終了した場合の移動先」に進みます。
   --------------------------------------------------------------------------------
    実機のように受信したファイルを管理する場合、受信したファイルの保存は次の行に進んだ際にのみ行うのではなく、
    終了コードが「Finish」の終了電文情報を作成する場合は常に行わなければならないことに注意してください。
    終了コードが「Finish」の終了REQ電文がサーバに届く可能性がある場合は、クライアントは受信したファイルを捨ててはなりません。
    これは、PassiveDllシーケンスの特性です。
    すなわち、シナリオのみで実機のような受信ファイルの管理を実現する場合は、作成した終了電文情報を（事前に初期化しておいたローカル変数などに）
    保存しておき、いずれかの移動先でその（ローカル変数が示す）終了コードをチェックする必要があります。
    なお、WaitForPassiveDllの「開始応答NAK事由」〜「検出待ち時間が経過した場合の移動先」のいずれかにドル記号が含まれている場合、
    その行に捕捉されたシーケンスの開始REQ電文は"$MachineDir<>\#PassiveDllReq.dat"で示されるファイルに書き出されますので、
    このファイル内からファイル名を抽出することで、受信したファイルにアクセスすることができます。
    これらのファイルは、そのシーケンスを実行中（すなわち、別の行に進むまでの間）のみアクセスできることに注意してください。
    シーケンスの実行が終了すれば、同名ファイルを新規作成する新たな受動的DLLシーケンスが開始する可能性があるためです。
    厳密には、別の行に進んだ後も、待機を行い得る行を実行するまでは、新たな受動的DLLシーケンスが開始する可能性はありませんが、
    その特性を積極的に活用する局面はあまり多くはないはずです。
   --------------------------------------------------------------------------------
    FTPによるファイル受信がタイムアウトした場合や、受信したファイルにハッシュ値異常を検出した場合は、
    終了電文情報の値は使用されません（送信する終了REQ電文の終了コードは「Abort」固定になります）。
    よって、ドル記号を含む値が記述されていても、その展開は実行されませんので、ご注意ください。
   --------------------------------------------------------------------------------
※ 電文を受信した際に、その電文が、WaitForXXXで待機を行っている複数の文脈の待機終了条件と合致する場合は、
   いずれか１つの文脈（最も早くから待機していた文脈）が示す応答返信またはREQ電文送信を行い、その文脈での待機のみを終了します。

※ (25),(26),(29),(32)の書式の行は、シーケンスが実行された際に実行する処理を登録するための行です。待機を行うわけではありません。
   これらの書式の行で処理が登録してある場合、当該のシーケンスの（= 当該シーケンスのタブのデータグリッドに登録されている種別の）
   正しいREQ電文を受信した際に、登録されている比較用電文と比較を行い、比較結果が一致の場合、新しい文脈を作成し、その文脈にて
   登録されている応答を返信して、登録されている処理を実行します。
   --------------------------------------------------------------------------------
    これらの行で登録してある処理が開始するケースでは、シミュレータから返信した応答を運管サーバ側が必ず処理する...
    という保証はありません。
    これは、これらのシーケンスの特性です。
   --------------------------------------------------------------------------------
※ (28)の書式の行も、シーケンスが実行された際に実行する処理を登録するための行です。待機を行うわけではありません。
   この書式の行で処理が登録してある場合、受動的ULLシーケンスの（= 「受動的ULL」タブのデータグリッドに登録されている種別の）
   正しいREQ電文を受信した際に比較が行われます。
   比較結果が不一致の場合は、受信電文に対する応答返信やそれに続くシーケンスをデフォルトの方法で処理し、当該行で指定された
   他のパラメータを参照しませんが、一致の場合は、新しい文脈を作成し、その文脈にて下記を行います。
   ・「開始応答NAK事由」が示す開始NAK電文または開始ACK電文の送信を行います。
   ・開始NAK電文を送信した場合、「開始NAK返信でシーケンス終了した場合に実行する処理」を実行します。
   ・開始ACK電文を送信した場合、「転送データファイルパス」が示すファイルのFTPによる送信を開始し、その結果により下記のいずれかを行います。
     ・FTPによるファイル送信が完了した場合は、終了コードが「Finish」の終了REQ電文を送信し、それに対するACK電文を受信した時点で、
       「シーケンス正常終了後に実行する処理」を実行します。
     ・FTPによるファイル送信がタイムアウトした場合は、終了コードが「Abort」の終了REQ電文を送信し、それに対する応答電文を受信した時点
       または応答電文の受信までに通信異常が発生した時点で「通信異常でシーケンス終了した場合に実行する処理」を実行します。
   ・開始ACK電文の送信で通信異常が発生した場合や、ファイル送信完了後に通信異常が発生した場合は、その時点で
     「通信異常でシーケンス終了した場合に実行する処理」を実行します。
   --------------------------------------------------------------------------------
    RegPassiveUllProcの「開始応答NAK事由」〜「シーケンス正常終了後に実行する処理」のいずれかにドル記号が含まれている場合、
    その行が登録したハンドラに捕捉されたシーケンスの開始REQ電文は"$MachineDir<>\#PassiveUllReq.dat"で示されるファイルに書き出されます。
    このファイルは、そのシーケンスを実行中（すなわち、登録した処理が開始されるまでの間）のみアクセスできることに注意してください。
    シーケンスの実行が終了すれば、同名ファイルを新規作成する新たな受動的ULLシーケンスが開始する可能性があるためです。
    厳密には、登録した処理が開始された後も、待機を行い得る行を実行するまでは、新たな受動的ULLシーケンスが開始する可能性はありませんが、
    その特性を積極的に活用する局面はあまり多くはないはずです。
   --------------------------------------------------------------------------------
※ (31)の書式の行も、シーケンスが実行された際に実行する処理を登録するための行です。待機を行うわけではありません。
   この書式の行で処理を登録した場合、受動的DLLシーケンスの（= 「受動的DLL」タブのデータグリッドに登録されている種別の）
   正しいREQ電文を受信した際に比較が行われます。
   比較結果が不一致の場合は、受信電文に対する応答返信やそれに続くシーケンスをデフォルトの方法で処理し、当該行で指定された
   他のパラメータを参照しませんが、一致の場合は、新しい文脈を作成し、その文脈にて下記を行います。
   ・「開始応答NAK事由」が示す開始NAK電文または開始ACK電文の送信を行います。
   ・開始NAK電文を送信した場合、「開始NAK返信でシーケンス終了した場合に実行する処理」を実行します。
   ・開始ACK電文を送信した場合、FTPによるファイル受信を開始し、その結果により下記のいずれかを行います。
     ・FTPによるファイル受信が完了した場合は、「終了電文情報」が示す終了REQ電文を送信し、それに対するACK電文を受信した時点で、
       「シーケンス正常終了後に実行する処理」を実行します。
     ・FTPによるファイル受信がタイムアウトした場合や、受信したファイルにハッシュ値異常を検出した場合は、終了コードが
       「Abort」の終了REQ電文を送信し、それに対する応答電文を受信した時点または応答電文の受信までに通信異常が発生した時点で
       「通信異常でシーケンス終了した場合に実行する処理」を実行します。
   ・開始ACK電文の送信で通信異常が発生した場合や、ファイル受信完了後に通信異常が発生した場合は、その時点で
     「通信異常でシーケンス終了した場合に実行する処理」を実行します。
   --------------------------------------------------------------------------------
    実機のように受信したファイルを管理する場合、受信したファイルの保存は「シーケンス正常終了後に実行する処理」でのみ行うのではなく、
    終了コードが「Finish」の終了電文情報を作成する場合は常に行わなければならないことに注意してください。
    終了コードが「Finish」の終了REQ電文がサーバに届く可能性がある場合は、クライアントは受信したファイルを捨ててはなりません。
    これは、PassiveDllシーケンスの特性です。
    すなわち、シナリオのみで実機のような受信ファイルの管理を実現する場合は、作成した終了電文情報を（事前に初期化しておいたローカル変数などに）
    保存しておき、開始したいずれかの処理でその（ローカル変数が示す）終了コードをチェックする必要があります。
    なお、RegPassiveDllProcの「開始応答NAK事由」〜「シーケンス正常終了後に実行する処理」のいずれかにドル記号が含まれている場合、
    その行が登録したハンドラに捕捉されたシーケンスの開始REQ電文は"$MachineDir<>\#PassiveDllReq.dat"で示されるファイルに書き出されますので、
    このファイル内からファイル名を抽出することで、受信したファイルにアクセスすることができます。
    これらのファイルは、そのシーケンスを実行中（すなわち、登録した処理が開始されるまでの間）のみアクセスできることに注意してください。
    シーケンスの実行が終了すれば、同名ファイルを新規作成する新たな受動的DLLシーケンスが開始する可能性があるためです。
    厳密には、登録した処理が開始された後も、待機を行い得る行を実行するまでは、新たな受動的DLLシーケンスが開始する可能性はありませんが、
    その特性を積極的に活用する局面はあまり多くはないはずです。
   --------------------------------------------------------------------------------
    FTPによるファイル受信がタイムアウトした場合や、受信したファイルにハッシュ値異常を検出した場合は、
    終了電文情報の値は使用されません（送信する終了REQ電文の終了コードは「Abort」固定になります）。
    よって、ドル記号を含む値が記述されていても、その展開は実行されませんので、ご注意ください。
   --------------------------------------------------------------------------------

※ 電文またはファイルを受信した際に、(25),(26),(28),(29),(31),(32)で登録されている複数の処理について、実行条件が成立する場合は、
   登録番号が最小のものが成立したとみなします。
   また、電文またはファイルを受信した際に、WaitForXXXで待機を行っている文脈の待機終了条件と、(25),(26),(28),(29),(31),(32)で
   登録されている処理の実行条件が、ともに成立する場合は、WaitForXXXの待機終了条件のみが成立したとみなします。
※(25),(26),(28),(29),(31),(32),(34),(36)で登録した処理は、実行条件が成立するたびに、専用の文脈（スレッドのようなもの）が用意され、
   実行中の他の処理と並行して実行されます。異なる番号で登録した異なる名前の処理や、異なる番号で登録した同名の処理だけが異なる文脈で
   実行されるわけではありません。同じ番号で１回だけ登録した処理であっても、実行条件が成立するたびに別の文脈が用意されます。
   即ち、条件が成立して実行を開始した後、処理全体の実行が終わる前に、再度実行条件が成立すれば、同じ処理が並行して実行されます。
   なお、複数の文脈で並行して能動的シーケンスを実行した場合であっても、文脈AがREQ電文を送信した後、それに対する応答電文を受信する前に、
   文脈Bが新たなREQ電文を送信するといったことはありません（文脈Bにおける新たなREQ電文の送信は、文脈Aの応答電文の受信を待ってから行われます）。
   また、既に開始している通信シーケンスにおけるREQ電文の送信前後（各種能動的シーケンス開始直後、各種ULLシーケンスや各種DLLシーケンスにおける
   ファイル転送の完了直後など）であっても、運管サーバからのREQ電文を受信すれば、それに対する応答電文は速やかに返信しますが、
   送信するREQ電文を構成するオクテットと返信する応答電文を構成するのオクテットが混ざることはありません（一方の電文全体を送信しきってから、
   他方の電文全体を送信します）。

※ (7)の「シーケンス成功時の送信電文ファイル削除要否」には「True」または「False」を記述してください。
   これが「True」の場合は、当該シーケンスで運管サーバからACK電文を受信した際に、「送信電文BINファイルパス」で指定された
   ファイルの削除が行われます。当該シーケンス用の電文を子プロセスや外部常駐プロセスに生成させることになっていて、
   これらのプロセスが、既存ファイルを上書きせずに、新たなファイルに出力するようになっている（運管サーバへの送信に
   成功するまで、ファイルを残すことを意図している）場合などに「True」を指定します。
※ (8)の「シーケンス成功時の転送データファイル削除要否」には「True」または「False」を記述してください。
   これが「True」の場合は、当該シーケンスでファイル転送終了のREQ電文を送信後、ACK電文を受信した際に、
   「転送データファイルパス」で指定されたファイルの削除が行われます。
   当該シーケンス用の転送データを子プロセスや外部常駐プロセスに生成させることになっていて、これらのプロセスが、
   既存ファイルがある場合にデータの追記を行う（または、新たなファイルに出力する）ようになっている（運管サーバへの
   送信に成功するまで、データを残すことを意図している）場合などに「True」を指定します。
※ 外部からのイベントを処理する機会を確保できるよう、(7)〜(16)を含まない繰り返しを検知すると、
   シナリオの実行は結果NGで終了します。よって、たとえば、成功するまでConnectを繰り返すようなシナリオを記述する場合は、
   失敗時にそのままConnectに戻るのではなく、Wait行を実行してからConnectに戻る等の配慮が必要です。

※ (40)の書式の行は、BINファイル（たとえば、受信データが保存されたBINファイル）の内容をチェックするための行です。
   対象BINファイルは、チェック対象とするBINファイルです。
   比較用BINファイルは、対象BINファイルと比較するためのファイルです。
   マスク用BINファイルは、比較の前に、対象BINファイルと比較用BINファイルに対しマスクを行うための（ビットANDする）ファイルです。
   対象BINファイルが存在しないことを確認する場合は、「比較用BINファイルパス」に何も記述しないでください。
   対象BINファイルが存在することだけを確認する場合は、「比較用BINファイルパス」に「*」を記述し、「比較バイト数」に0を記述してください。
   対象BINファイルのサイズが任意のバイト数以上であることを確認する場合は、「比較用BINファイルパス」に「*」を記述し、「比較バイト数」に任意の正数（バイト数）を記述してください。
   対象BINファイルの有無等に関係なく、比較結果を常に一致させる場合は、「比較用BINファイルパス」に「*」を記述し、「比較バイト数」に負数を記述してください。
   対象BINファイルの内容を確認する場合は、「比較用BINファイルパス」に実在するファイルのパスを記述してください。
   以下、比較用BINファイルパス」に実在するファイルのパスを記述した場合についての動作を説明します。
     「比較バイト数」を0とした場合、比較結果は常に一致となります。
     「比較バイト数」が正数の場合は、「比較バイト数」分だけが比較の対象になります。
       その場合、比較用BINファイルやマスク用BINファイルの長さが「比較バイト数」未満なら、足りない分は0x00が埋められているものとして処理が行われます。
       また、対象BINファイルの長さが「比較バイト数」未満なら、比較結果は不一致となります。
       また、対象BINファイルの長さが「比較バイト数」以上なら、対象BINファイルの長さと比較用BINファイルの長さが異なっても、比較結果が不一致になるとは限りません。
       また、「マスク用BINファイルパス」に「*」を記述すると、対象BINファイルの長さと「比較バイト数」のみが比較され、対象BINファイルが「比較バイト数」よりも短い場合が不一致となります。
     「比較バイト数」が負数の場合は、比較用BINファイル全体が比較に用いられることになります。
       その場合、マスク用BINファイルが比較用BINファイルより短ければ、足りない分は0x00が埋められているものとして処理が行われます。
       また、対象BINファイルと比較用BINファイルの長さが不一致なら、たとえ短い側のバイト数分の内容が完全一致していても、比較結果は不一致となります。
       また、「マスク用BINファイルパス」に「*」を記述すると、対象BINファイルと比較用BINファイルの長さのみが比較されます。長さが一致しなければ、比較結果は不一致となります。
※ (41)の書式の行は、CSVファイル（たとえば、受信データが保存されたCSVファイル）の内容をチェックするための行です。
   対象CSVファイルは、チェック対象とするCSVファイルです。
   比較用CSVファイルは、対象CSVファイルと比較するためのファイルです。
   マスク用CSVファイルは、比較の前に、対象CSVファイルと比較用CSVファイルに対しマスクを行うためのCSVファイルです。
   対象CSVファイルが存在しないことを確認する場合は、「比較用CSVファイルパス」に何も記述しないでください。
   対象CSVファイルが存在することだけを確認する場合は、「比較用CSVファイルパス」に「*」を記述し、「比較項目数」に0を記述してください。
   対象CSVファイルの項目数が任意数以上であることを確認する場合は、「比較用CSVファイルパス」に「*」を記述し、「比較項目数」に任意の正数（項目数）を記述してください。
   対象CSVファイルの有無等に関係なく、比較結果を常に一致させる場合は、「比較用CSVファイルパス」に「*」を記述し、「比較項目数」に負数を記述してください。
   対象CSVファイルの内容を確認する場合は、「比較用CSVファイルパス」に実在するファイルのパスを記述してください。
   以下、比較用CSVファイルパス」に実在するファイルのパスを記述した場合についての動作を説明します。
     「比較項目数」を0とした場合、比較結果は常に一致となります。
     「比較項目数」が正数の場合は、先頭から「比較項目数」分の項目だけが比較の対象になります。
       その場合、比較用CSVファイルやマスク用CSVファイルの項目数が「比較項目数」より少なければ、足りない分は0が埋められているものとして処理が行われます。
       また、対象CSVファイルの項目数が「比較項目数」未満なら、比較結果は不一致となります。
       また、対象CSVファイルの項目数が「比較項目数」以上なら、対象CSVファイルの項目数と比較用CSVファイルの項目数が異なっても、比較結果が不一致になるとは限りません。
       また、「マスク用CSVファイルパス」に「*」を記述すると、対象CSVファイルの項目数と「比較項目数」のみが比較され、対象CSVファイルの項目数が「比較項目数」よりも少ない場合が不一致となります。
     「比較項目数」が負数の場合は、比較用CSVファイル全体が比較に用いられることになります。
       その場合、マスク用CSVファイルの項目数が比較用CSVファイルの項目数より少なければ、足りない分は0が埋められているものとして処理が行われます。
       また、対象CSVファイルと比較用CSVファイルの項目数が不一致なら、たとえ少ない側の項目数分の内容が完全一致していても、比較結果は不一致となります。
       また、「マスク用CSVファイルパス」に「*」を記述すると、対象CSVファイルと比較用CSVファイルの項目数のみが比較されます。項目数が一致しなければ、比較結果は不一致となります。
※ マスク用CSVファイルの各項目は、対象CSVファイルと比較用CSVファイルの当該項目に対する「比較対象文字数」として使用されます。
   「比較対象文字数」が正数の項目は、先頭から「比較対象文字数」分の文字だけが比較の対象になります。
       その場合、対象CSVファイルや比較用CSVファイルの当該項目の文字数が「比較対象文字数」未満なら、比較結果は不一致となります。
       また、対象CSVファイルおよび比較用CSVファイルの当該項目の文字数が「比較対象文字数」以上なら、対象CSVファイルと比較用CSVファイルで当該項目の文字数が異なっても、比較結果が不一致になるとは限りません。
   「比較対象文字数」が負数の項目は、対象CSVファイルの当該項目と比較用CSVファイルの当該項目の文字列全体が比較されます。
       その場合、対象CSVファイルの当該項目と比較用CSVファイルの当該項目の文字数が不一致なら、たとえ短い側の文字数分の内容が完全一致していても、比較結果は不一致となります。

※ Proc行とEndProc行の間に記述された「実行機器 ConnectやGoToといった固定文字列 カンマで区切られた文字列」の形式の行
   における「カンマで区切られた文字列」の個々の要素をパラメータと呼びますが、
   あらゆるパラメータにおいて、"%"で始まる部分文字列は、シナリオをロードした時点で以下のように置換されます。
      %桁M  : 模擬対象駅務機器の機種コード
      %桁R  : 模擬対象駅務機器の線区コード
      %桁S  : 模擬対象駅務機器の駅順コード
      %桁C  : 模擬対象駅務機器のコーナーコード
      %桁U  : 模擬対象駅務機器の号機番号
      %桁I  : 模擬対象駅務機器の項番（シミュレータ内の駅務機器における通し番号）
      %T桁R : 端末機器の線区コード
      %T桁S : 端末機器の駅順コード
      %T桁C : 端末機器のコーナーコード
      %T桁U : 端末機器の号機番号
      %T桁I : 端末機器の項番（駅務機器内における通し番号）
      %%    : 1文字の"%"
    桁には1〜9の半角数字を記述してください。その桁数になるようゼロ埋めが行われます。
    桁を記述しない場合は、ゼロサプレスが行われます。
    %Tが１つでも記述されている行は、シナリオをロードした時点で、模擬対象駅務機器の配下にある端末機器の台数分の行に差し替えられます。

※ あらゆるパラメータ内における"$[シンボル]"や"$関数名<引数リスト>"の形式で記述された部分文字列は、
   その行を実行する時点で（「受信電文や受信データの保存先」や「返信電文や返信データを格納したファイル」を
   意味するパラメータ内のものについては、電文の受信時点や返信時点で）動的に展開されます。
   "$関数名<引数リスト>"の引数リストには、関数に渡す引数をセミコロンで区切って記述しますが、
   個々の引数の中にも"$[シンボル]"や"$関数名<引数リスト>"を記述することが可能です。
   "$関数名<引数リスト>"の箇所は、関数の戻り値に展開されます。
   関数の戻り値の中に"$[シンボル]"や"$関数名<引数リスト>"の形式の文字列が含まれていても、
   それらが再展開されることはありません。
   以下に"$[シンボル]"や"$関数名<引数リスト>"の一覧を記載します。
    $[,]
        カンマに展開されます。カンマを直接記述せずにこの形式で記述すれば、当該のカンマはパラメータの区切りとみなされることはありません。
    $[;]
        セミコロンに展開されます。セミコロンを直接記述せずにこの形式で記述すれば、当該のセミコロンは引数の区切りとみなされることはありません。
    $[$]
        ドル記号に展開されます。ドル記号を直接記述せずにこの形式で記述すれば、展開後のドル記号が展開箇所の開始記号とみなされることはありません。
    $[>]
        大なり記号に展開されます。大なり記号を直接記述せずにこの形式で記述すれば、当該の大なり記号は引数リストの終端とみなされることはありません。
    $[ ]
        空白に展開されます。空白を直接記述せずにこの形式で記述すれば、当該の空白がパラメータ区切りや引数区切りに隣接していてもトリミング対象にはなりません。
    $[HT]
        水平タブに展開されます。水平タブを直接記述せずにこの形式で記述すれば、当該の水平タブがパラメータ区切りや引数区切りに隣接していてもトリミング対象にはなりません。
    $[CR]
        改行文字（キャリッジリターン）に展開されます。
    $[LF]
        改行文字（ラインフィード）に展開されます。
    $[NUL]
        ヌル文字に展開されます。

    $MachineDir<>
        子プロセスor外部常駐プロセス向け公開ディレクトリ（駅務機器別）の絶対パス名に展開されます。
    $ContextDir<>
        子プロセスor外部常駐プロセス用作業ディレクトリ（駅務機器別かつ文脈別）の絶対パス名に展開されます。
    $ContextNum<>
        文脈番号に展開されます。

    $MidStr<文字列; 抽出開始位置; 最大抽出文字数>
        文字列の中の指定した位置から指定した文字数の部分文字列を抽出して戻り値とします。
        抽出開始位置は文字単位の位置を0起算で記述してください。
        抽出開始位置が負値の場合や文字列の文字数以上の場合も、エラーとはみなしません。
        抽出開始位置＋最大抽出文字数が負値の場合や文字列の文字数以上の場合も、エラーとはみなしません。
        それらのケースでは、最大抽出文字数よりも少ない文字数の部分文字列が戻り値となります。
    $LeftStr<文字列; 最大抽出文字数>
        文字列の先頭から指定した文字数の部分文字列を抽出します。
        最大抽出文字数が文字列の文字数以上の場合も、エラーとはみなしません。
        そのケースでは、文字列と同じ内容の文字列が戻り値となります。
    $RightStr<文字列; 最大抽出文字数>
        文字列の末尾から指定した文字数の部分文字列を抽出します。
        最大抽出文字数が文字列の文字数以上の場合も、エラーとはみなしません。
        そのケースでは、文字列と同じ内容の文字列が戻り値となります。
    $StrElem<文字列; 抽出位置>
        文字列の中の指定した位置から1文字を抽出して戻り値とします。
        抽出位置は文字単位の位置を0起算で記述してください。
        抽出位置が文字列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $InStr<文字列; 検索文字列> or <文字列; 検索文字列; 検索開始位置> or <文字列; 検索文字列; 検索開始位置; 最大検索文字数>
        文字列の中から検索文字列と一致する箇所を探して、その位置を戻り値とします。
        検索は文字列の先頭から開始し、一致する箇所を最初にみつけた時点で終了します。
        みつからない場合、戻り値は-1となります。
        指定した検索範囲の全部または一部が文字列の外部を指す場合も、エラーとはみなしません。
    $InStrRev<文字列; 検索文字列> or <文字列; 検索文字列; 検索開始位置> or <文字列; 検索文字列; 検索開始位置; 最大検索文字数>
        文字列の中から検索文字列と一致する箇所を探して、その位置を戻り値とします。
        検索は文字列の末尾から開始し、一致する箇所を最初にみつけた時点で終了します。
        みつからない場合、戻り値は-1となります。
        指定した検索範囲の全部または一部が文字列の外部を指す場合も、エラーとはみなしません。
    $StrLen<文字列>
        文字列の文字数を算出し、戻り値とします。
    $Replace<文字列; 置換する部分文字列; 置換後の部分文字列>
        文字列の中の「置換する部分文字列」と一致する箇所すべてを「置換後の部分文字列」に差し替えた文字列を作成し、戻り値とします。
    $TrimSp<文字列>
        文字列の先頭および末尾に存在する連続した空白文字類（空白と水平タブ）を除去した文字列を作成し、戻り値とします。
    $TrimBr<文字列>
        文字列の先頭および末尾に存在する連続した改行文字類（CRとLF）を除去した文字列を作成し、戻り値とします。
    $Trim<文字列>
        文字列の先頭および末尾に存在する連続した空白文字類（空白と水平タブ）と改行文字類（CRとLF）を除去した文字列を作成し、戻り値とします。
    $ToUpper<文字列>
        文字列の中の半角小文字のアルファベットすべてを半角大文字に差し替えた文字列を作成し、戻り値とします。
    $ToLower<文字列>
        文字列の中の半角大文字のアルファベットすべてを半角小文字に差し替えた文字列を作成し、戻り値とします。
    $Format<複合書式指定文字列; 書式指定項目に渡す数値や日時のセミコロン区切りリスト>
        複合書式指定文字列の書式指定項目に「書式指定項目に渡す数値や日時のセミコロン区切りリスト」の数値や日時を設定した文字列を作成し、戻り値とします。
        複合書式指定文字列の仕様については、Microsoft .NET Framework における複合書式指定文字列の仕様と同等です。
        書式指定項目とは複合書式指定文字列に含まれる{項目番号}や{項目番号:書式}の形式の文字列です。
        たとえば{2:D4}という書式指定項目には、「書式指定項目に渡す数値や日時のセミコロン区切りリスト」の
        要素2（0起算なので3番目の要素）に記述された整数が10進4桁で設定されます。
        たとえば{3:MM/dd/yy}という書式指定項目には、「書式指定項目に渡す数値や日時のセミコロン区切りリスト」の
        要素3（0起算なので4番目の要素）に記述された日時の月（ゼロ埋め2桁）、日（ゼロ埋め2桁）、年（下2桁）が「/」区切りで設定されます。
        複合書式指定文字列と「書式指定項目に渡す数値や日時のセミコロン区切りリスト」が整合しない場合、シナリオの実行は結果NGで終了します。
    $BytesFrStr<文字列; EncodingID> or <文字列; EncodingID; バイト数> or <文字列; EncodingID; バイト数; 余白バイト16進コード>
        文字列を指定された文字エンコーディングのバイト列にエンコードし、戻り値とします。
        バイト列は複数のバイトをハイフンでつないだ文字列で表現され、個々のバイトは2桁の16進数になります。
        文字エンコーディングは、コードページID（たとえばシフトJISなら932）でもコードページ名（たとえばシフトJISならshift_jis）でも構いません。
        バイト数を指定した場合は、指定したバイト数分のバイト列が戻り値となります。
        エンコード結果が指定したバイト数よりも長くなる場合、シナリオの実行は結果NGで終了します。
    $StrMin<セミコロンで区切られた複数の文字列>
        引数で渡された文字列の中から序数比較（StrCmp）の結果で最小とみなされるものを選択し、戻り値とします。
    $StrMax<セミコロンで区切られた複数の文字列>
        引数で渡された文字列の中から序数比較（StrCmp）の結果で最大とみなされるものを選択し、戻り値とします。

    $MidBytes<バイト列; 抽出開始位置; 抽出バイト数>
        バイト列の中の指定した位置から指定したバイト数の部分バイト列を抽出して戻り値とします。
        バイト列は複数のバイトをハイフンでつないだ文字列です。個々のバイトは2桁の16進数でなければなりません。
        抽出開始位置はバイト単位の位置を0起算で記述してください。
        指定した抽出範囲の全部または一部がバイト列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $LeftBytes<バイト列; 抽出バイト数>
        バイト列の先頭から指定したバイト数の部分バイト列を抽出して戻り値とします。
        バイト列は複数のバイトをハイフンでつないだ文字列です。個々のバイトは2桁の16進数でなければなりません。
        指定した抽出範囲の全部または一部がバイト列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $RightBytes<バイト列; 抽出バイト数>
        バイト列の末尾から指定したバイト数の部分バイト列を抽出して戻り値とします。
        バイト列は複数のバイトをハイフンでつないだ文字列です。個々のバイトは2桁の16進数でなければなりません。
        指定した抽出範囲の全部または一部がバイト列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $BytesElem<バイト列; 抽出位置>
        バイト列の中の指定した位置から1バイトを抽出して戻り値とします。
        バイト列は複数のバイトをハイフンでつないだ文字列です。個々のバイトは2桁の16進数でなければなりません。
        抽出位置はバイト単位の位置を0起算で記述してください。
        抽出位置がバイト列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $InBytes<バイト列; 検索バイト列> or <バイト列; 検索バイト列; 検索開始位置> or <バイト列; 検索バイト列; 検索開始位置; 最大検索バイト数>
        バイト列の中から検索バイト列と一致する箇所を探して、その位置を戻り値とします。
        検索はバイト列の先頭から開始し、一致する箇所を最初に見つけた時点で終了します。
        みつからない場合、戻り値は-1となります。
        指定した検索範囲の全部または一部がバイト列の外部を指す場合も、エラーとはみなしません。
    $BytesLen<バイト列>
        バイト列のバイト数を算出し、戻り値とします。
    $BitAndOfBytes<バイト列; バイト列>
        ２つのバイト列のビットごとの論理積からなるバイト列を生成し、戻り値とします。
        ２つのバイト列のバイト数が異なる場合は、短い方のバイト列の不足分バイトが全て00であるものとみなして処理を行います
        （戻り値のバイト数は長い方のバイト数と同等になります）。
    $BitOrOfBytes<バイト列; バイト列>
        ２つのバイト列のビットごとの論理和からなるバイト列を生成し、戻り値とします。
        ２つのバイト列のバイト数が異なる場合は、短い方のバイト列の不足分バイトが全て00であるものとみなして処理を行います
        （戻り値のバイト数は長い方のバイト数と同等になります）。
    $BitXorOfBytes<バイト列; バイト列>
        ２つのバイト列のビットごとの排他的論理和からなるバイト列を生成し、戻り値とします。
        ２つのバイト列のバイト数が異なる場合は、短い方のバイト列の不足分バイトが全て00であるものとみなして処理を行います
        （戻り値のバイト数は長い方のバイト数と同等になります）。
    $BitNotOfBytes<バイト列>
        バイト列の各ビットを反転させたバイト列を生成し、戻り値とします。
    $UIntFrLeBytes<バイト列>
        バイト列から取得した無符号整数を戻り値とします。
        無符号整数の取得はバイト列のバイト順がリトルエンディアンである想定で行います。
        無符号整数は10進文字列で表現します。
        たとえば、バイト列が01-56-FEの場合、戻り値は16668161になります。
    $UIntFrBeBytes<バイト列>
        バイト列から取得した無符号整数を戻り値とします。
        無符号整数の取得はバイト列のバイト順がビッグエンディアンである想定で行います。
        無符号整数は10進文字列で表現します。
        たとえば、バイト列がFE-56-01の場合、戻り値は16668161になります。
    $IntFrLeBytes<バイト列>
        バイト列から取得した整数を戻り値とします。
        整数の取得はバイト列のバイト順がリトルエンディアンである想定で行います。
        整数は10進文字列で表現し、負数の場合のみ符号（-）がつきます。
        たとえば、バイト列が01-56-FEの場合、戻り値は-109055になります。
    $IntFrBeBytes<バイト列>
        バイト列から取得した整数を戻り値とします。
        整数の取得はバイト列のバイト順がビッグエンディアンである想定で行います。
        整数は10進文字列で表現し、負数の場合のみ符号（-）がつきます。
        たとえば、バイト列がFE-56-01の場合、戻り値は-109055になります。
    $LeBytesFrInt<整数値; バイト数>
        10進文字列で表される整数を格納した指定バイト数のバイト列を生成し、戻り値とします。
        バイト列への格納はリトルエンディアンで行います。
        たとえば整数値が16668161でバイト数が3の場合、戻り値は01-56-FEになります。
        整数値が-109055でバイト数が3の場合も、戻り値は01-56-FEになります。
        整数値が指定されたバイト数に格納できない場合、シナリオの実行は結果NGで終了します。
    $BeBytesFrInt<整数値; バイト数>
        10進文字列で表される整数を格納した指定バイト数のバイト列を生成し、戻り値とします。
        バイト列への格納はビッグエンディアンで行います。
        たとえば整数値が16668161でバイト数が3の場合、戻り値はFE-56-01になります。
        整数値が-109055でバイト数が3の場合も、戻り値はFE-56-01になります。
        整数値が指定されたバイト数に格納できない場合、シナリオの実行は結果NGで終了します。

    $MidFields<項目列; 抽出開始位置; 抽出項目数>
        項目列の中の指定した位置から指定した項目数の部分項目列を抽出して戻り値とします。
        項目列は空白区切りの文字列です。
        抽出開始位置は項目単位の位置を0起算で記述してください。
        指定した抽出範囲の全部または一部が項目列の外部を指す場合、シナリオの実行は結果NGで終了します。
        -----------------------------------------------------------------------
        項目列の中の"!"は特殊文字であり、"!"に続く2文字は16進のASCIIコードとみなします。
        よって、区切りではない空白は"!20"、!記号は"!21"で記述可能です。
        "!"に続く2文字が16進数とみなせない場合や、"!"に続く2文字の16進数がASCIIコードと
        みなせない場合、シナリオの実行は結果NGで終了します。
        -----------------------------------------------------------------------
    $LeftFields<項目列; 抽出項目数>
        項目列の先頭から指定した項目数の部分項目列を抽出して戻り値とします。
        項目列は空白区切りの文字列です。
        指定した抽出範囲の全部または一部が項目列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $RightFields<項目列; 抽出項目数>
        項目列の末尾から指定した項目数の部分項目列を抽出して戻り値とします。
        項目列は空白区切りの文字列です。
        指定した抽出範囲の全部または一部が項目列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $FieldsElem<項目列; 抽出位置>
        項目列の中の指定した位置から1項目を抽出して戻り値とします。
        項目列は空白区切りの文字列です。
        抽出位置は項目単位の位置を0起算で記述してください。
        抽出位置が項目列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $InFields<項目列; 検索項目列> or <項目列; 検索項目列; 検索開始位置> or <項目列; 検索項目列; 検索開始位置; 最大検索項目数>
        項目列の中から検索項目列と一致する箇所を探して、その位置を戻り値とします。
        検索は項目列の先頭から開始し、一致する箇所を最初に見つけた時点で終了します。
        みつからない場合、戻り値は-1となります。
        指定した検索範囲の全部または一部が項目列の外部を指す場合も、エラーとはみなしません。
    $FieldsLen<項目列>
        項目列の項目数を算出し、戻り値とします。

    $MidArray<要素列; 抽出開始位置; 抽出要素数>
        要素列の中の指定した位置から指定した要素数の部分要素列を抽出して戻り値とします。
        要素列はセミコロン区切りの文字列です。
        抽出開始位置は要素番号を0起算で記述してください。
        指定した抽出範囲の全部または一部が要素列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $LeftArray<要素列; 抽出要素数>
        要素列の先頭から指定した要素数の部分要素列を抽出して戻り値とします。
        要素列はセミコロン区切りの文字列です。
        指定した抽出範囲の全部または一部が要素列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $RightArray<要素列; 抽出要素数>
        要素列の末尾から指定した要素数の部分要素列を抽出して戻り値とします。
        要素列はセミコロン区切りの文字列です。
        指定した抽出範囲の全部または一部が要素列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $ArrayElem<要素列; 抽出位置>
        要素列の中の指定した位置から1要素を抽出して戻り値とします。
        要素列はセミコロン区切りの文字列です。
        抽出位置は要素単位の位置を0起算で記述してください。
        抽出位置が要素列の外部を指す場合、シナリオの実行は結果NGで終了します。
    $InArray<要素列; 検索要素>
        要素列の中から検索要素と一致する要素を探して、その要素番号を戻り値とします。
        検索は要素列の先頭から開始し、一致する要素を最初に見つけた時点で終了します。
        みつからない場合、戻り値は-1となります。
        指定した検索範囲の全部または一部が要素列の外部を指す場合も、エラーとはみなしません。
    $ArrayLen<要素列>
        要素列の要素数を算出し、戻り値とします。
    $ValidateSep<文字列>
        区切り文字とみなされないようになっているセミコロンを区切り文字とみなすようにします。
        区切り文字とみなされないようになっているセミコロンとは、$[;]の形式で記述されたセミコロンや、
        他の関数の戻り値として出現するセミコロンです。
        この関数は、他の関数によって生成されたセミコロン区切りの文字列を要素列みなして
        ArrayLen関数などに渡したい場合に使用します。

    $Add<数値１; 数値２>
        ２つの数値の加算結果を戻り値とします。
        数値は10進数で表現された文字列です。
        Microsoft .NET Framework のDecimal構造体と同じ範囲の数値を同じ精度で表現可能です。
        小数点や負符号（-）を含んでも構いません。
        無符号整数値や整数値も数値の一種です。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Sub<数値１; 数値２>
        数値１から数値２を引いた結果を戻り値とします。
        数値は10進数で表現された文字列です。
        Microsoft .NET Framework のDecimal構造体と同じ範囲の数値を同じ精度で表現可能です。
        小数点や負符号（-）を含んでも構いません。
        無符号整数値や整数値も数値の一種です。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Mul<数値１; 数値２>
        ２つの数値の乗算結果を戻り値とします。
        数値は10進数で表現された文字列です。
        Microsoft .NET Framework のDecimal構造体と同じ範囲の数値を同じ精度で表現可能です。
        小数点や負符号（-）を含んでも構いません。
        無符号整数値や整数値も数値の一種です。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Div<数値１; 数値２>
        数値１を数値２で除算した結果を戻り値とします。
        数値は10進数で表現された文字列です。
        Microsoft .NET Framework のDecimal構造体と同じ範囲の数値を同じ精度で表現可能です。
        小数点や負符号（-）を含んでも構いません。
        無符号整数値や整数値も数値の一種です。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Quotient<数値１; 数値２>
        数値１を数値２で除算した結果の整数桁を戻り値とします。
        数値は10進数で表現された文字列です。
        Microsoft .NET Framework のDecimal構造体と同じ範囲の数値を同じ精度で表現可能です。
        小数点や負符号（-）を含んでも構いません。
        無符号整数値や整数値も数値の一種です。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Remainder<数値; 数値>
        数値１を数値２で除算した結果生じる剰余を戻り値とします。
        数値は10進数で表現された文字列です。
        Microsoft .NET Framework のDecimal構造体と同じ範囲の数値を同じ精度で表現可能です。
        小数点や負符号（-）を含んでも構いません。
        無符号整数値や整数値も数値の一種です。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Neg<数値>
        数値の正負を反転させた結果を戻り値とします。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Abs<数値>
        数値の絶対値を戻り値とします。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Int<数値>
        数値の整数桁を戻り値とします。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Ceil<数値>
        数値以上の最小の整数値を戻り値とします。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Floor<数値>
        数値を負の無限大方向の近似整数に丸めた結果を戻り値とします。
        引数が数値とみなせない場合、シナリオの実行は結果NGで終了します。
    $Min<セミコロンで区切られた複数の数値>
        引数で渡された数値の中で最小のものを選択し、戻り値とします。
        引数の中に数値とみなせないものがあれば、シナリオの実行は結果NGで終了します。
    $Max<セミコロンで区切られた複数の数値>
        引数で渡された数値の中で最大のものを選択し、戻り値とします。
        引数の中に数値とみなせないものがあれば、シナリオの実行は結果NGで終了します。

    $Now<>
        現在日時を戻り値とします。
        出力する日時の形式は「yyyy/MM/dd hh:mm:ss.fff」です。
    $TimeDiff<日時１; 日時２>
        「日時２ - 日時１」の時間をミリ秒単位の整数値で返却します。
        引数が日時とみなせない場合、シナリオの実行は結果NGで終了します。
    $TimeAfter<日時; 時間>
        日時に時間を加えた日時を算出し、戻り値とします。
        時間は、数値に「ms」「s」「m」「h」「d」のいずれかを付与した文字列です。
        引数が日時および時間とみなせない場合、シナリオの実行は結果NGで終了します。
    $TimeBefore<日時; 時間>
        日時から時間を引いた日時を算出し、戻り値とします。
        時間は、数値に「ms」「s」「m」「h」「d」のいずれかを付与した文字列です。
        引数が日時および時間とみなせない場合、シナリオの実行は結果NGで終了します。

    $IsMatchBinFiles<評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス> or <評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス; 評価バイト数>
        評価対象ファイルが基準に適合するか判定します。適合したか否かを表す真偽値が戻り値となります。
        真偽値はTrueまたはFalseいずれかの文字列で表現されます。
        判定方法はCheckBinFileステートメントと同じです。
        評価バイト数のないオーバーロードでは、-1が評価バイト数になります。
    $IsMatchCsvFiles<評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス> or <評価対象ファイルのパス; 基準ファイルのパス; マスク用ファイルのパス; 評価項目数>
        評価対象ファイルが基準に適合するか判定します。適合したか否かを表す真偽値が戻り値となります。
        真偽値はTrueまたはFalseいずれかの文字列で表現されます。
        判定方法はCheckCsvFileステートメントと同じです。
        評価項目数のないオーバーロードでは、-1が評価項目数になります。
    $StrEq<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        等しければTrue、等しくなければFalseが戻り値となります。
    $StrNeq<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        等しくなければTrue、等しければFalseが戻り値となります。
    $StrGeq<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        文字列１ >= 文字列２ なら戻り値はTrueとなります。
    $StrGt<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        文字列１ > 文字列２ なら戻り値はTrueとなります。
    $StrLeq<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        文字列１ <= 文字列２ なら戻り値はTrueとなります。
    $StrLt<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        文字列１ < 文字列２ なら戻り値はTrueとなります。
    $StrCmp<文字列１; 文字列２>
        ２つの文字列を序数比較します。
        文字列１ < 文字列２ なら戻り値は-1になります。
        文字列１ == 文字列２ なら戻り値は0になります。
        文字列１ > 文字列２ なら戻り値は1になります。
    $IsZero<数値>
        数値が0と等しいか判定します。
        0と等しければTrue、0以外の数値ならFalseが戻り値となります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $IsNega<数値>
        数値が0未満であるか判定します。
        0未満の数値ならTrue、0以上の数値ならFalseが戻り値となります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $IsPosi<数値>
        数値が0超であるか判定します。
        0超の数値ならTrue、0以下の数値ならFalseが戻り値となります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $Eq<数値１; 数値２>
        ２つの数値を比較します。
        等しければTrue、等しくなければFalseが戻り値となります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $Neq<数値１; 数値２>
        ２つの数値を比較します。
        等しくなければTrue、等しければFalseが戻り値となります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $Geq<数値１; 数値２>
        ２つの数値を比較します。
        数値１ >= 数値２ なら戻り値はTrueとなります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $Gt<数値１; 数値２>
        ２つの数値を比較します。
        数値１ > 数値２ なら戻り値はTrueとなります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $Leq<数値１; 数値２>
        ２つの数値を比較します。
        数値１ <= 数値２ なら戻り値はTrueとなります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $Lt<数値１; 数値２>
        ２つの数値を比較します。
        数値１ < 数値２ なら戻り値はTrueとなります。
        引数が数値とみなせなければ、シナリオの実行は結果NGで終了します。
    $And<セミコロンで区切られた複数の真偽値>
        引数の全てがTrueならTrue、１つでもFalseならFalseを返却します。
        引数にTrueでもFalseでないものが混ざっている場合、シナリオの実行は結果NGで終了します。
    $Or<セミコロンで区切られた複数の真偽値>
        引数の全てがFalseならFalse、１つでもTrueならTrueを返却します。
        引数にTrueでもFalseでないものが混ざっている場合、シナリオの実行は結果NGで終了します。
    $Not<真偽値>
        引数がFalseならTrue、TrueならFalseを返却します。
    $If<真偽値; 結果文字列１; 結果文字列２>
        真偽値がTrueなら結果文字列１、Falseなら結果文字列２が戻り値となります。
        ２つの結果文字列は、真偽値によらず、どちらも展開の対象であることに注意してください。
        現状の文法では、真偽値によって実行する関数を選択したい場合、それらの関数を別の行に記述する必要が
        あります（それぞれの行にラベルをつけて GoTo $If<条件式; ラベル１; ラベル２> などで分岐可能です）。
        真偽値がTrueでもFalseでない場合、シナリオの実行は結果NGで終了します。

    $NewFileOfStr<パス; EncodingID; 文字列>
        パスにテキストファイルを作成します。
        パスにファイルが存在している場合は、ファイルの内容をクリアしてから書きなおします。
        戻り値はパスになります。
    $NewFileOfBytes<パス; バイト列>
        パスにバイナリファイルを作成します。
        パスにファイルが存在している場合は、ファイルの内容をクリアしてから書きなおします。
        戻り値はパスになります。
    $AppendStrToFile<文字列; パス; EncodingID>
        パスが示すファイルに文字列を追記します。
        パスが示すファイルが存在しない場合は、新規作成します。
        戻り値は追記した文字列にります。
    $AppendBytesToFile<バイト列; パス>
        パスが示すファイルにバイト列を追記します。
        パスが示すファイルが存在しない場合は、新規作成します。
        戻り値は追記したバイト列にります。
    $StrFrFile<パス; EncodingID>
        パスが示すファイル全体から文字列を取得し、戻り値とします。
    $BytesFrFile<パス>
        パスが示すファイル全体からバイト列を取得し、戻り値とします。

    $SetVal<変数名; 代入する値>
        変数に値を代入します。
        変数が参照型変数の場合は、その参照先の変数に値を代入します。
        戻り値は代入した値です。
        変数名の変数がスコープに存在しない場合、変数名が値型変数のものであれば、その場で変数を用意しますが、
        変数名が参照型変数のものであるなら、シナリオの実行は結果NGで終了します。
        -----------------------------------------------------------------------
        変数は以下の３種類に大別されます。
          値型グローバル変数：
            名前の１文字目が"@"の変数です。
            任意の文字列を保持することができます。
            どの文脈におけるどの呼び出し先からもアクセスできます。
          値型ローカル変数：
            名前の１文字目が"@"でも"*"でもない変数です。
            任意の文字列を保持することができます。
            同じ名前であっても、各文脈における呼び出し先ごとに独立しています。
            呼び出しから戻った際や文脈が消滅した際に消滅します。
          参照型ローカル変数：
            名前の１文字目が"*"の変数です。
            値型変数へのリンクを保持します。
            同じ名前であっても、各文脈における呼び出し先ごとに独立しています。
            呼び出しから戻った際や文脈が消滅した際に消滅します。
        -----------------------------------------------------------------------
        Procが呼び元から情報を受け取るための仮引数も変数であり、名前によって
        値型ローカル変数、参照型ローカル変数のいずれかになります。
        -----------------------------------------------------------------------
        １つのパラメータの中に、同じ変数に関する$SetVal<...>と$Val<...>が含まれているとして、
        $Val<...>が、$SetVal<...>と同階層の後方に記述されている場合や$SetVal<...>の外側の階層に記述されている
        場合（たとえば $Val<$If<True; 変数名１; $SetVal<変数名１; 値１>>> のような場合）は、
        $Val<...>において更新された変数の値を取得できるはずです。
        -----------------------------------------------------------------------
    $SetRef<参照型変数名の２文字目以降; 変数名>
        「変数名」で示される変数を参照する参照型変数を用意します。
        参照型変数の変数名は「参照型変数名の２文字目以降」の前に"*"を付与したものになります。
        同名の参照型変数が既にスコープに存在している場合は、その参照先を変更します。
        戻り値は用意した（もしくは更新した）参照型変数の変数名です。
    $Val<変数名>
        変数の値を返却します。
        変数が参照型変数の場合は、その参照先の変数の値を返却します。

    $ExecDynFunc<関数完全名; 関数の実引数>
        関数完全名で示されるVB.NET関数またはC#関数（以下、ドットネット関数と記述）を実行します。
        ドットネット関数の戻り値が戻り値になります。
        関数完全名の関数が存在しない場合や、関数の実行で例外がスローされた場合、シナリオの実行は結果NGで終了します。
        関数完全名の形式は「コードブロック名.クラス名.関数名」です。
        「コードブロック名」は、(80)または(90)の書式の行で定義した名前でなければなりません。
        「クラス名」は、上記の行〜(81)または(91)の行によって生み出される.NETアセンブリ内に存在するPublicなクラスの名前でなければなりません。
        「関数名」は、上記クラス内に定義され、０個〜任意個の値渡しのStringのみを引数とし、Stringを戻り値とするPublicな静的関数の名前でなければなりません。
        「関数の実引数」はセミコロンで区切ることができます。
    $ExecCmdFunc<コマンド名; コマンド引数; コマンド実行待ち時間>
        コマンド名で示される実行ファイルを子プロセスとして起動し、子プロセスの終了を待ちます。
        子プロセスが終了した場合、子プロセスが標準出力に出力した文字列が戻り値になります。
        コマンド実行待ち時間内に子プロセスが終了しない場合、シナリオの実行は結果NGで終了します。
        「コマンド引数」はセミコロンで区切ることができます。
    $ExecAppFunc<MSMQ名; 要求内容; 応答待ち時間>
        MSMQ名で示されるローカルPCのメッセージキューに「要求内容」を格納したメッセージを送信することで
        外部常駐プロセスに任意の処理を要求し、当該プロセスからの応答メッセージを待ちます。
        応答メッセージを受信した場合、応答メッセージに格納された文字列が戻り値になります。
        応答待ち時間内に応答を受信できない場合、シナリオの実行は結果NGで終了します。
        「要求内容」はセミコロンで区切ることができます。

※ WaitForFooで待つ際の比較に用いるパラメータは待機開始時に展開され、Contextに保持されます。展開結果はWaitForFooの完了とともに消滅します。
※ RegFooProcで登録する処理の比較用のパラメータは登録時に展開され、Handlerごとに保持されます。展開結果はUnregFooProcによりHandlerとともに消滅します。
※ 「日時」や「時間」のように書式が決められているパラメータも、ドル記号が１つでも含まれている場合は、ロード時点で書式のチェックを実施しません。
   よって、書式の誤りが判明するのは、そのパラメータが評価される時（ドル記号で始まる部位を展開した後）になりますので、ご注意ください。

※ (80)の書式の行と(81)の書式の行の間には、VB.NET形式のソースプログラムとして解釈され、この範囲ごとに.NETアセンブリが生成されます。
   (90)の書式の行と(91)の書式の行の間には、C#形式のソースプログラムとして解釈され、この範囲ごとに.NETアセンブリが生成されます。
   これらのソースプログラムの書式は通常のVB.NETやC#から多少拡張されており、以下のディレクティブを記述可能です。
     (A)多くのシナリオで共有するためのファイルの内容を挿入するためのディレクティブ
       #include <挿入するファイルのシミュレータ起動ディレクトリからの相対パス名>
     (B)シナリオ内で共有するためのファイルの内容を挿入するためのディレクティブ
       #include "挿入するファイルのシナリオファイル格納ディレクトリからの相対パス名"
     (C)参照する.NETアセンブリ（GAC登録済み）を指定するためのディレクティブ
       #refer <参照するアセンブリのdllファイル名>
     (D)参照する.NETアセンブリ（GAC未登録）を指定するためのディレクティブ
       #refer "参照するアセンブリのdllファイルのシミュレータEXEファイルからの相対パス名"
   (A)や(B)で挿入するファイルの内部にも(A)(B)(C)(D)のディレクティブを記述可能です。
   (A)や(B)のディレクティブで指定されるファイルが既に挿入済み（または挿入中）の場合は、当該ディレクティブは自動的に無効化されます。
   (C)や(D)のディレクティブで指定されるファイルが既に参照対象になっている場合は、当該ディレクティブは自動的に無効化されます。
   なお、(A)や(B)は純粋な挿入を行います。たとえばVB.NET言語では、Importsステートメントを他のステートメントよりも先に記述しなければなりませんので、
   (A)や(B)で挿入するファイルにImports以外のステートメントが含まれる場合、(A)や(B)はImportsステートメントよりも後に記述しなければならないことに注意しください。
※ 複数の駅務機器（= 複数のスレッド）で(80)〜(81)や(90)〜(91)を含むシナリオを実行する場合、それらの部位の内容が
   完全一致するなら、そこから生成されるAssemblyインスタンスは１つであり、全ての駅務機器で共有されます。
   また、シナリオの実行が終わっても、それは主記憶上にとどまり続けます。
   よって、クラスに状態を持たせる（クラス変数を用意する）場合は、以下のことに注意してください。
   ・クラス変数は基本的にスレッドローカルにするべきです。
     そうでない（駅務機器間で共有させたい）ものについては、たとえばクラス変数が参照型であり、参照先のオブジェクト
     をクラスのロード時にセットしているとするなら、シナリオから使用されるメソッドでは、オブジェクトの参照を
     キーにしたSyncLockなどで排他制御を行うべきです（当該オブジェクトがImmutableでないならば）。
   ・スレッド別のクラス変数はシナリオ開始時にシナリオから初期化する（初期化用に用意したメソッドを呼び出す）べきです。

--

◆シミュレータが外部常駐プロセスに要求を行う上で送受信するメッセージ

シナリオからの指示で外部常駐プロセスに送信するメッセージは、AppSpecificが0でExtAppFuncMessageBody型のBodyを持ち、
ResponseQueueプロパティに多重駅務機器シミュレータのメッセージキューがセットされます。
要求メッセージのBody（ExtAppFuncMessageBody）の各メンバは下記のようになります。
  WorkingDirectory: 外部常駐プロセス用の作業ディレクトリ（駅務機器別かつ文脈別）の絶対パス
  Func: シナリオに記述された「要求内容」の先頭要素（「要求内容」にセミコロンが含まれていない場合は「要求内容」そのもの）
  Args: シナリオに記述された「要求内容」の先頭以外の要素（「要求内容」にセミコロンが含まれていない場合はNothing）

多重駅務機器シミュレータから上記メッセージを受信した外部常駐プロセスは、ResponseQueueプロパティの示すメッセージキューに対し、
AppSpecificが0でExtAppFuncMessageBody型のBodyを持つ応答メッセージを返信しなければなりません。
要求メッセージのBody（ExtAppFuncMessageBody）の各メンバには下記のようにセットしなければなりません。
  WorkingDirectory: 要求メッセージと同じ値
  Completed: 要求の実行が成功したか否か

--

◆外部常駐プロセスがシミュレータに要求を行う上で送信するべきメッセージ

外部常駐プロセスからは、多重駅務機器シミュレータのメッセージキュー（.\private$\ExOpmgMultiplexEkimuSim@起動ディレクトリ名）に対して
AppSpecificが1でExtSimFuncMessageBody型のBodyを持つメッセージを送信することで、多重駅務機器シミュレータをリモート操作することも可能です。
多重駅務機器シミュレータが解釈可能なメッセージ（BodyにセットされるExtSimFuncMessageBodyのメンバ）は下記になります。

(1)運管サーバとの回線接続を要求するメッセージ
    Verb: "Connect"
    Params: なし
(2)運管サーバとの回線切断を要求するメッセージ
    Verb: "Disconnect"
    Params: なし
(3)運管サーバとの単発電文送信シーケンス実行を要求するメッセージ
    Verb: "ActiveOne" または "TryActiveOne"
    Params(0): 送信電文ファイルパス As String
    Params(1): 応答電文待ち時間(ms) As Integer
    Params(2): リトライ間隔(ms) As Integer
    Params(3): 正常とみなすべきNAK受信時のリトライの最大回数 As Integer
    Params(4): 継続すべきでないNAK受信時のリトライの最大回数 As Integer
    Params(5): シーケンス成功時の送信電文ファイル削除要否 As Boolean
(4)運管サーバとの能動的ULLシーケンス実行を要求するメッセージ
    Verb: "ActiveUll" または "TryActiveUll"
    Params(0): データ種別 As Integer
    Params(1): 転送データファイルパス As String
    Params(2): 転送データファイルハッシュ値 As String
    Params(3): 転送待ち時間(ms) As Integer
    Params(4): 開始応答電文待ち時間(ms) As Integer
    Params(5): 終了応答電文待ち時間(ms) As Integer
    Params(6): リトライ間隔(ms) As Integer
    Params(7): 正常とみなすべきNAK受信時のリトライの最大回数 As Integer
    Params(8): 継続すべきでないNAK受信時のリトライの最大回数 As Integer
    Params(9): シーケンス成功時の転送データファイル削除要否 As Boolean
